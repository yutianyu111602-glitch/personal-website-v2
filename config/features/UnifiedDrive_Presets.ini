[meta]
name = UnifiedDrive Preset Suite
version = 1.0.0
author = you+assistant
updated = 2025-08-24
description = UnifiedDrive (E,A,R) → 参数 + 预设矩阵 + 统一预设管理器（给 Cursor 的一份 INI 指令与全部代码）

[cursor.plan]
# 目标
# 1) 把本 INI 中的所有 [file] 段落写到磁盘，形成一个可编译的 TypeScript 包
# 2) 在你项目中引入后，只通过 (E,A,R) 三元向量和“预设矩阵”即可驱动整套可视化
# 3) 统一管理：矩阵预设 (matrix presets) + 组合配方 (combos) + 时段规则 (rules)

# 执行步骤（Cursor）
# A) 新建一个空目录（或放在你的仓库下），把本 INI 保存为 UnifiedDrive_Presets.ini
# B) 新建文件 tools/unpack-ini.ts，复制 [bootstrap.extractor] 的代码
# C) 运行：  npx ts-node tools/unpack-ini.ts UnifiedDrive_Presets.ini
# D) 执行：  pnpm i typescript --save-dev   &&   pnpm exec tsc -p .
# E) 在你的引擎中： import { UnifiedPresetManager, selectPreset, drive } from './src/index'
# F) 按 docs/CURSOR_TASKS.md 接线（保留音乐可视化操作台：E/A/R 滑杆 + Stage 切换）

[bootstrap.extractor]
# 这是把 INI 的 [file] 段写成文件的小工具（先手工建这个文件，再执行）
path = tools/unpack-ini.ts
content = |-
  import * as fs from 'fs';
  import * as path from 'path';
  const iniPath = process.argv[2] || 'UnifiedDrive_Presets.ini';
  const txt = fs.readFileSync(iniPath, 'utf-8');
  const lines = txt.split(/\r?\n/);
  const files:any[] = [];
  for (let i=0;i<lines.length;i++){
    const line = lines[i].trim();
    if (line === '[file]'){
      let p = '', content = '', inBlock = false;
      for (i=i+1; i<lines.length; i++){
        const l = lines[i];
        if (l.trim().startsWith('path =')){ p = l.split('path =')[1].trim(); }
        else if (l.trim().startsWith('content = |-')){ inBlock = true; }
        else if (l.trim() === '---END---'){ inBlock = false; break; }
        else if (l.trim().startsWith('[') && !inBlock){ i--; break; }
        else { if (inBlock) content += l + '\n'; }
      }
      if (!p) continue;
      files.push({path:p, content});
    }
  }
  for (const f of files){
    const out = path.join(process.cwd(), f.path);
    fs.mkdirSync(path.dirname(out), { recursive: true });
    fs.writeFileSync(out, f.content, 'utf-8');
    console.log('WROTE', f.path);
  }
  console.log('Done. Total files:', files.length);

[file]
path = package.json
content = |-
  {
    "name": "unified-drive-suite",
    "version": "1.0.0",
    "type": "module",
    "license": "MIT",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
      "build": "tsc -p .",
      "check": "tsc -p . --noEmit"
    }
  }
---END---

[file]
path = tsconfig.json
content = |-
  {
    "compilerOptions": {
      "target": "ES2020",
      "module": "ES2020",
      "declaration": true,
      "outDir": "dist",
      "strict": true,
      "moduleResolution": "Node",
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*.ts","docs/**/*.md"]
  }
---END---

[file]
path = docs/CURSOR_TASKS.md
content = |-
  # Cursor 执行清单（保留音乐可视化操作台）
  1. 新建 `tools/unpack-ini.ts`（用 [bootstrap.extractor] 内容）
  2. 运行：`npx ts-node tools/unpack-ini.ts UnifiedDrive_Presets.ini`
  3. 安装 TypeScript 并编译：`pnpm i -D typescript && pnpm exec tsc -p .`
  4. 在你的渲染循环：
     ```ts
     import { UnifiedPresetManager, makeUnifiedVector } from './src';
     const upm = new UnifiedPresetManager();
     upm.setMatrixPreset('BalancedSilver'); // 可切换
     // 你的数据：
     const mood = { energy, valence, arousal };
     const audio = { rms, flux, crest, centroid, beatConf };
     const stage = detectStage(); // idle/build/drop/fill
     const U = makeUnifiedVector(mood, audio, stage);
     const { weights, uniforms } = upm.drive(U);
     // 写入渲染器（Global 与 node-scope 分别处理）
     ```
  5. 操作台（UI 你来做）：E/A/R 三滑杆 + Stage 切换 + 预设下拉。把 setMatrixPreset(name) / drive(U) 接上即可。
---END---

[file]
path = src/types/BlendTypes.ts
content = |-
  export type BlendID =
    | 'LumaSoftOverlay' | 'SMix' | 'BoundedDodge' | 'SoftBurn' | 'GrainMerge'
    | 'StructureMix' | 'BloomHL' | 'EdgeTint' | 'DualCurve' | 'TemporalTrail'
    | 'SpecularGrad' | 'OkLabLightness';
  export type BlendNode = { id:BlendID; weight:number; uniforms?:Record<string,number>; category?:'Base'|'Accent'|'Decor'; };
  export type BlendPipeline = { nodes:BlendNode[]; ttlMs?:number; presetId?:string; extras?: any; };
  export type UnifiedVector = { E:number; A:number; R:number };
  export type Assignments = {
    weights: { id:BlendID; weight:number }[];
    uniforms: { scope:'global'|'node'; nodeId?:BlendID; key:string; value:number }[];
  };
---END---

[file]
path = src/drive/UnifiedDrive.ts
content = |-
  import { BlendID, BlendPipeline, UnifiedVector, Assignments } from "../types/BlendTypes";
  export type DriveOptions = { clampTotalW?: number; nodeCap?: number; brightCapBase?: number; mapping?: (ear:UnifiedVector)=>Record<BlendID,number>; uniformsMap?: (ear:UnifiedVector)=>Record<string,number>; };
  const clamp=(x:number,a=0,b=1)=>Math.min(b,Math.max(a,x));
  const L=(x:number)=>clamp(x,0,1);
  export function normalizeEAR(EAR:UnifiedVector){ return {E:L(EAR.E),A:L(EAR.A),R:L(EAR.R)}; }
  export function defaultWeights(EAR:UnifiedVector, nodeCap=0.22){
    const {E,A,R}=normalizeEAR(EAR);
    const W:Record<BlendID,number>={
      LumaSoftOverlay:0.08+0.15*(1-A),
      SMix:0.07+0.12*(1-Math.abs(R-0.5)*2),
      OkLabLightness:0.05+0.15*R,
      BoundedDodge:0.04+0.18*E,
      SoftBurn:0.03+0.12*(1-R),
      StructureMix:0.05+0.12*A,
      DualCurve:0.05+0.14*E+0.06*A,
      SpecularGrad:0.04+0.10*A,
      GrainMerge:0.03+0.08*(1-A),
      BloomHL:0.03+0.15*E*(1-R),
      EdgeTint:0.02+0.10*A*R,
      TemporalTrail:0.02+0.08*(1-R)+0.05*E,
    } as any;
    (Object.keys(W) as BlendID[]).forEach(k=> W[k]=Math.min(nodeCap,W[k]));
    return W;
  }
  export function defaultUniforms(EAR:UnifiedVector,brightCapBase=0.7){
    const {E,A,R}=normalizeEAR(EAR);
    return {
      'Global.uBrightCap': brightCapBase+0.3*E,
      'Global.uJitter': 0.01+0.05*A,
      'Global.uVividGate': 0.2+0.7*E*(1-R),
      'SpecularGrad.uLightPhase': (R%1)*6.28318530718,
      'Flow.flowAmp': 0.01+0.05*A,
      'Flow.flowScale': 0.8+0.5*R,
      'Caustic.strength': 0.2+0.6*(E*A),
      'Worley.cellSharp': 0.4+0.5*(1-R),
      'Polar.rippleAmp': 0.1+0.4*A,
      'RD.f': 0.04+0.02*(1-R),
    } as Record<string,number>;
  }
  export function clampTotalWeights(W:Record<BlendID,number>, clampTotalW=0.35){
    const sum=(Object.values(W) as number[]).reduce((a,b)=>a+b,0); const k=sum>clampTotalW?clampTotalW/sum:1;
    const out:Record<BlendID,number>={} as any; (Object.keys(W) as BlendID[]).forEach(id=> out[id]=W[id]*k); return out;
  }
  export function toAssignments(EAR:UnifiedVector, opts:DriveOptions={}):Assignments{
    const clampTotalW=opts.clampTotalW??0.35, nodeCap=opts.nodeCap??0.22, brightBase=opts.brightCapBase??0.7;
    const W0=(opts.mapping??defaultWeights)(EAR,nodeCap) as any; const W=clampTotalWeights(W0,clampTotalW);
    const U=(opts.uniformsMap??defaultUniforms)(EAR,brightBase);
    const weights=(Object.keys(W) as BlendID[]).map(id=>({id,weight:W[id]}));
    const uniforms=Object.entries(U).map(([key,value])=>{
      if(key.startsWith('Global.')) return {scope:'global' as const,key:key.replace(/^Global\./,''),value};
      const m=key.match(/^([A-Za-z0-9_]+)\.(.+)$/); if(m) return {scope:'node' as const,nodeId:m[1] as any,key:m[2],value};
      return {scope:'global' as const,key,value};
    });
    return {weights,uniforms};
  }
  export function mergeIntoPipeline(pipeline:BlendPipeline, EAR:UnifiedVector, opts:DriveOptions={}):BlendPipeline{
    const next:BlendPipeline={...pipeline,nodes:pipeline.nodes.map(n=>({...n,uniforms:{...(n.uniforms||{})}}))};
    const {weights,uniforms}=toAssignments(EAR,opts);
    const map=new Map(next.nodes.map(n=>[n.id,n.weight] as const));
    weights.forEach(w=> map.set(w.id,(map.get(w.id)||0)+w.weight));
    const sum=Array.from(map.values()).reduce((a,b)=>a+b,0); const cap=opts.clampTotalW??0.35; const k=sum>cap?cap/sum:1; const nodeCap=opts.nodeCap??0.22;
    next.nodes=Array.from(map.entries()).map(([id,weight])=>({id,weight:Math.min(nodeCap,weight*k)})) as any;
    const globals:Record<string,number>={}; uniforms.forEach(u=>{ if(u.scope==='global') globals[u.key]=u.value; });
    next.nodes=next.nodes.map(n=>{ const nu={...(globals),...(n.uniforms||{})} as Record<string,number>; uniforms.forEach(u=>{ if(u.scope==='node'&&u.nodeId===n.id) nu[u.key]=u.value; }); return {...n,uniforms:nu}; });
    return next;
  }
  export const drive = toAssignments;
---END---

[file]
path = src/drive/UnifiedDriveAdapters.ts
content = |-
  import { UnifiedVector } from "../types/BlendTypes";
  export type Mood = { energy:number; valence:number; arousal:number };
  export type Audio = { rms:number; flux:number; crest:number; centroid:number; beatConf:number };
  export type Stage = 'idle'|'build'|'drop'|'fill';
  const L=(x:number)=>Math.min(1,Math.max(0,x));
  export function makeUnifiedVector(mood:Mood, audio:Audio, stage:Stage): UnifiedVector {
    const E = L( 0.55*mood.energy + 0.30*audio.rms + 0.15*(stage==='drop'?1:stage==='build'?0.6:0) );
    const A = L( 0.50*mood.arousal + 0.35*audio.flux + 0.15*audio.crest );
    const R = L( 0.60*(1-audio.flux) + 0.25*(stage==='idle'||stage==='build'?1:0.2) + 0.15*(1-Math.abs(mood.valence)) );
    return { E, A, R };
  }
---END---

[file]
path = src/drive/UnifiedDrivePresets.ts
content = |-
  import { UnifiedVector, BlendID } from "../types/BlendTypes";
  type WeightMap = (ear:UnifiedVector, nodeCap?:number)=>Record<BlendID,number>;
  type UniformMap = (ear:UnifiedVector)=>Record<string,number>;
  export type MatrixPreset = { name:string; idea:string; weights:WeightMap; uniforms?:UniformMap };
  import { defaultWeights, defaultUniforms, normalizeEAR } from "./UnifiedDrive";

  function cap(W:Record<BlendID,number>,cap=0.22){ (Object.keys(W) as BlendID[]).forEach(k=> W[k]=Math.min(cap,W[k])); return W; }

  export const MatrixPresets: MatrixPreset[] = [
    { name:'BalancedSilver', idea:'稳健银色，长时间观看友好', weights: (ear,capN)=> cap(defaultWeights(ear,capN)) , uniforms: defaultUniforms },
    { name:'ContrastShock', idea:'高对比极端爆闪，Techno 高能段', weights: (ear,capN)=>{
        const {E,A,R}=normalizeEAR(ear); const W:any={
          LumaSoftOverlay:0.05+0.05*(1-A),
          SMix:0.06+0.06*(1-Math.abs(R-0.5)*2),
          OkLabLightness:0.05+0.05*R,
          BoundedDodge:0.02+0.25*E,
          SoftBurn:0.05+0.20*(1-R),
          StructureMix:0.04+0.20*A,
          DualCurve:0.02+0.20*E+0.10*A,
          SpecularGrad:0.04+0.10*A,
          GrainMerge:0.03+0.05*(1-A),
          BloomHL:0.02+0.18*E*(1-R),
          EdgeTint:0.02+0.08*A*R,
          TemporalTrail:0.03+0.10*(1-R)+0.05*E,
        }; return cap(W,capN);
      }, uniforms: (ear)=>{ const {E,R}=normalizeEAR(ear); return {'Global.uVividGate':0.5+0.5*E*(1-R),'Global.uBrightCap':0.6+0.4*E}; } },
    { name:'AmbientMist', idea:'冷雾银面，几乎不爆亮', weights:(ear,capN)=>{
        const {A,R}=normalizeEAR(ear); const W:any={
          LumaSoftOverlay:0.12+0.08*R, SMix:0.10, OkLabLightness:0.12+0.10*R,
          GrainMerge:0.06+0.05*(1-A), TemporalTrail:0.04+0.06*(1-R),
          BoundedDodge:0.02, DualCurve:0.03, SpecularGrad:0.03, StructureMix:0.04, BloomHL:0.02, EdgeTint:0.02
        }; return cap(W,capN);
      }, uniforms:(_)=>({'Global.uBrightCap':0.75}) },
    { name:'ChaosStorm', idea:'规律越低越狂躁', weights:(ear,capN)=>{
        const {E,A,R}=normalizeEAR(ear); const W:any={
          SoftBurn:0.08+0.18*(1-R), TemporalTrail:0.06+0.14*(1-R), GrainMerge:0.05+0.10*(1-R),
          BloomHL:0.08*E*(1-R), DualCurve:0.05+0.10*A+0.10*(1-R),
          StructureMix:0.05+0.10*A, SpecularGrad:0.04+0.08*A, EdgeTint:0.02+0.06*A,
          LumaSoftOverlay:0.05, SMix:0.05, OkLabLightness:0.05
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {R}=normalizeEAR(ear); return {'Global.uJitter':0.02+0.08*(1-R),'Global.uVividGate':0.4+0.6*(1-R)}; } },
    { name:'BeatPulse', idea:'与节拍同步，镜面高光相位跟 R', weights:(ear,capN)=>{
        const {E,A,R}=normalizeEAR(ear); const W:any={
          StructureMix:0.06+0.12*A, SpecularGrad:0.04+0.08*A+0.08*R, DualCurve:0.04+0.12*E+0.06*R, EdgeTint:0.03+0.12*A*R,
          LumaSoftOverlay:0.07, SMix:0.06, OkLabLightness:0.06, GrainMerge:0.04, TemporalTrail:0.03, BoundedDodge:0.05, BloomHL:0.04, SoftBurn:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {E,R}=normalizeEAR(ear); return {'SpecularGrad.uLightPhase': (R%1)*6.2831853,'Global.uBrightCap':0.8+0.2*E}; } },
    { name:'LiquidFlow', idea:'液态流场感，A 驱动速度', weights:(ear,capN)=>{
        const {E,A,R}=normalizeEAR(ear); const W:any={
          StructureMix:0.06+0.14*A, DualCurve:0.06+0.10*E, LumaSoftOverlay:0.08+0.1*(1-A),
          SMix:0.07, OkLabLightness:0.07, TemporalTrail:0.03+0.05*A, GrainMerge:0.04, EdgeTint:0.03, SpecularGrad:0.04, BoundedDodge:0.04, BloomHL:0.03, SoftBurn:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {A,R}=normalizeEAR(ear); return {'Flow.flowAmp':0.01+0.05*A,'Flow.flowScale':0.8+0.5*R}; } },
    { name:'FractureIce', idea:'裂纹/冰感，低 R 变锋利', weights:(ear,capN)=>{
        const {E,R}=normalizeEAR(ear); const W:any={
          StructureMix:0.06+0.10*(1-R), GrainMerge:0.05, DualCurve:0.06, SpecularGrad:0.05, BoundedDodge:0.05, SoftBurn:0.04, EdgeTint:0.03, TemporalTrail:0.04, SMix:0.06, LumaSoftOverlay:0.06, OkLabLightness:0.06, BloomHL:0.04+0.06*E
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {E,R}=normalizeEAR(ear); return {'Worley.cellSharp':0.4+0.5*(1-R),'Global.uBrightCap':0.65+0.35*E}; } },
    { name:'CausticGlow', idea:'水波焦散在银面上舞动', weights:(ear,capN)=>{
        const {E,A}=normalizeEAR(ear); const W:any={
          OkLabLightness:0.10, SMix:0.08, LumaSoftOverlay:0.08, StructureMix:0.06, DualCurve:0.05, SpecularGrad:0.05, GrainMerge:0.04, TemporalTrail:0.03, BoundedDodge:0.04, BloomHL:0.04, SoftBurn:0.03, EdgeTint:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {E,A}=normalizeEAR(ear); return {'Caustic.strength':0.2+0.6*(E*A)}; } },
    { name:'PolarVortex', idea:'极坐标漩涡，A 驱动波幅', weights:(ear,capN)=>{
        const {E,A}=normalizeEAR(ear); const W:any={
          DualCurve:0.08+0.12*E, LumaSoftOverlay:0.06, SMix:0.06, OkLabLightness:0.06, StructureMix:0.06+0.06*A, SpecularGrad:0.05, GrainMerge:0.04, TemporalTrail:0.04, BoundedDodge:0.05, BloomHL:0.04, SoftBurn:0.03, EdgeTint:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {A}=normalizeEAR(ear); return {'Polar.rippleAmp':0.1+0.4*A}; } },
    { name:'RDOrganism', idea:'反应扩散像银色细胞在呼吸', weights:(ear,capN)=>{
        const {R}=normalizeEAR(ear); const W:any={
          SMix:0.1, OkLabLightness:0.08, LumaSoftOverlay:0.06, StructureMix:0.06, DualCurve:0.05, SpecularGrad:0.05, GrainMerge:0.04, TemporalTrail:0.04, BoundedDodge:0.04, BloomHL:0.03, SoftBurn:0.03, EdgeTint:0.02
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {R}=normalizeEAR(ear); return {'RD.f':0.04+0.02*(1-R)}; } },
    { name:'AnisoMetal', idea:'拉丝金属与镜面高光', weights:(ear,capN)=>{
        const {A,R}=normalizeEAR(ear); const W:any={
          SpecularGrad:0.06+0.10*A, LumaSoftOverlay:0.06, OkLabLightness:0.06+0.06*R, SMix:0.06, StructureMix:0.06, DualCurve:0.05, GrainMerge:0.04, TemporalTrail:0.03, BoundedDodge:0.04, BloomHL:0.03, SoftBurn:0.03, EdgeTint:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {R}=normalizeEAR(ear); return {'SpecularGrad.uLightPhase':(R%1)*6.2831853}; } },
    { name:'PsyChaos', idea:'迷幻拉丝抖动，深夜段插入', weights:(ear,capN)=>{
        const {E,A}=normalizeEAR(ear); const W:any={
          DualCurve:0.10+0.10*A, SpecularGrad:0.06+0.08*A, LumaSoftOverlay:0.05, SMix:0.05, OkLabLightness:0.05, StructureMix:0.05, GrainMerge:0.04, TemporalTrail:0.05, BoundedDodge:0.05+0.05*E, BloomHL:0.04+0.06*E, SoftBurn:0.03, EdgeTint:0.03
        }; return cap(W,capN);
      }, uniforms:(ear)=>{ const {E,A}=normalizeEAR(ear); return {'Global.uVividGate':0.5+0.5*E,'Global.uJitter':0.02+0.08*A}; } }
  ];

  export function getPreset(name:string){ const p=MatrixPresets.find(p=>p.name===name); if(!p) throw new Error('Preset not found: '+name); return p; }
---END---

[file]
path = src/drive/UnifiedPresetManager.ts
content = |-
  import { UnifiedVector, Assignments, BlendPipeline } from "../types/BlendTypes";
  import { toAssignments, defaultWeights, defaultUniforms } from "./UnifiedDrive";
  import { MatrixPresets, getPreset, MatrixPreset } from "./UnifiedDrivePresets";

  export class UnifiedPresetManager {
    private preset: MatrixPreset = MatrixPresets[0];
    setMatrixPreset(name:string){ this.preset = getPreset(name); }
    getMatrixPreset(){ return this.preset.name; }

    drive(ear:UnifiedVector, opts?:{ clampTotalW?:number; nodeCap?:number; brightCapBase?:number }): Assignments {
      const weightsMap = (ear2:UnifiedVector, cap?:number)=> this.preset.weights(ear2, cap);
      const uniformsMap = (ear2:UnifiedVector)=> ({ ...(defaultUniforms(ear2, opts?.brightCapBase)), ...(this.preset.uniforms ? this.preset.uniforms(ear2) : {}) });
      return toAssignments(ear, { clampTotalW:opts?.clampTotalW, nodeCap:opts?.nodeCap, brightCapBase:opts?.brightCapBase, mapping: weightsMap as any, uniformsMap });
    }

    mergePipeline(p:BlendPipeline, ear:UnifiedVector, opts?:{ clampTotalW?:number; nodeCap?:number; brightCapBase?:number }): BlendPipeline {
      const a = this.drive(ear, opts);
      const map = new Map(p.nodes.map(n=>[n.id,n] as const));
      a.weights.forEach(w=>{
        const n = map.get(w.id);
        if(n) n.weight = Math.min(opts?.nodeCap ?? 0.22, n.weight + w.weight);
        else p.nodes.push({ id: w.id, weight: Math.min(opts?.nodeCap ?? 0.22, w.weight) } as any);
      });
      const globals:Record<string,number>={}; a.uniforms.forEach(u=> u.scope==='global' && (globals[u.key]=u.value));
      p.nodes = p.nodes.map(n=>{
        const nu = { ...(n.uniforms||{}), ...globals } as Record<string,number>;
        a.uniforms.forEach(u=>{ if(u.scope==='node' && u.nodeId===n.id) nu[u.key]=u.value; });
        return { ...n, uniforms: nu };
      });
      // ΣW 限制
      const sum = p.nodes.reduce((acc,n)=>acc+n.weight,0); const cap = opts?.clampTotalW ?? 0.35; const k=sum>cap?cap/sum:1;
      p.nodes.forEach(n=> n.weight = Math.min(opts?.nodeCap ?? 0.22, n.weight*k));
      return p;
    }

    listPresets(){ return MatrixPresets.map(p=>({ name:p.name, idea:p.idea })); }
  }
---END---

[file]
path = src/index.ts
content = |-
  export * from './types/BlendTypes';
  export * from './drive/UnifiedDrive';
  export * from './drive/UnifiedDriveAdapters';
  export * from './drive/UnifiedDrivePresets';
  export * from './drive/UnifiedPresetManager';
---END---

[file]
path = README_Plain.md
content = |-
  # 白话版：UnifiedDrive 预设套件怎么用？
  - 三根滑杆：E（能量）、A（激活）、R（规律）。
  - 选择一个“风格预设”（BalancedSilver / ContrastShock / AmbientMist / ChaosStorm / BeatPulse / LiquidFlow / FractureIce / CausticGlow / PolarVortex / RDOrganism / AnisoMetal / PsyChaos）。
  - 把 `(E,A,R)` 喂给 `UnifiedPresetManager.drive()`，得到权重和参数，写入你的渲染器。
  - 操作台：三个滑杆 + 预设下拉 + Stage 切换（idle/build/drop/fill）。

  ## 1 分钟上手
  ```ts
  import { UnifiedPresetManager, makeUnifiedVector } from './src';
  const mgr = new UnifiedPresetManager();
  mgr.setMatrixPreset('BalancedSilver');
  const U = makeUnifiedVector({energy:0.7,valence:0.1,arousal:0.8},{rms:0.6,flux:0.55,crest:0.5,centroid:0.4,beatConf:0.7},'build');
  const {weights,uniforms} = mgr.drive(U);
  // 把 weights/uniforms 写进你的管线即可
  ```
---END---
