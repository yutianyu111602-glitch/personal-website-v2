1. 最小步骤执行（防超时/防崩溃）
Phase 1 — 后端就位（2 选 1）
	1	TS API（推荐）
	◦	解压 aidjmix-autoplaylist-api-ts.zip
	◦	npm i
	◦	npm run dev（默认端口 8787）
	◦	自测：curl -X POST http://localhost:8787/api/aidjmix/autoplaylist \
	◦	  -H 'Content-Type: application/json' \
	◦	  -d '{"tracks":[{"id":"t1","durationSec":240,"bpm":128,"keyCamelot":"8A","path":"/music/a.mp3"}],"minutes":60,"beamWidth":24}'
	◦	
	◦	收到 { ok:true, plan, m3u, txt } 即成功。
	2	Python CLI（离线流水线）
	◦	解压 aidjmix-autoplaylist-python.zip
	◦	python -m venv .venv && source .venv/bin/activate
	◦	pip install -r requirements.txt
	◦	试跑：python -m aidjmix.cli data/tracks.example.json out/ --minutes 60 --beam 24 --techno 1
	◦	
	◦	out/ 里会有 m3u/txt/json。
Phase 2 — 前端桥接
	1	解压 aidjmix-frontend-bridge.zip，把 AidjPlaylistClient.ts 放进你的前端（和 UnifiedEventBus 同项目）。
	2	在你现有的初始化处加几行（不改你的接口）：import { AidjPlaylistClient } from './clients/AidjPlaylistClient';
	3	const client = new AidjPlaylistClient('/api/aidjmix/autoplaylist'); // 指向 Phase1 的后端
	4	// TODO: 从你的曲库取 TrackFeature[]（字段见下）
	5	client.requestAutoPlaylist(tracks, 60, 24);
	6	
	7	订阅事件（你现在就有总线了）：
	◦	namespace:'automix', type:'plan' → 拿到 { plan, m3u, txt } 直接给电台/播放器
	◦	namespace:'automix', type:'error' → toast 提示
Phase 3 — 与你给的 Manager 融合（保持接口原样）
	•	你的 AutoDJManager / AutoMixManager 不改现有方法，只可选增加一个“绑定自动歌单客户端”的口子（我已在文档包里给了 PATCH_AutoDJ_AutoMix.diff）。
	•	极简做法（不打补丁也行）：在页面某个按钮点击时调用上面的 client.requestAutoPlaylist(...)，收到 plan/m3u 后照你现在的播放管线推进。
Phase 4 — 数据字段对齐（最小必需）

type TrackFeature = {
  id: string; durationSec: number; bpm: number; keyCamelot: string; path: string;
  cueInSec?: number; cueOutSec?: number;
  // 可选：energyCurve?: number[]; downbeats?: number[]; vocality?: number; title?: string; artist?: string;
}
你已有的 BPM/对拍/调性可直接填；更高级特征位都留了“空接口”注释，随时替换。
Phase 5 — 性能与可靠性（防阻塞）
	•	前端 fetch 30s 超时，错误走 automix:error，回退你的原播放逻辑。
	•	Beam 宽度默认 24；曲库>2000 时先降到 12–16。
	•	服务器端可通过 TARGET_MINUTES / MAX_STRETCH_PCT / BEAM_WIDTH / PORT 环境变量调参（文档有例子）。
Phase 6 — Techno 预设调优
	•	已内置：BPM 128±4 加权、小调(A)偏好、能量平滑、24 拍 crossfade、“低频交接（bass swap）”自动化建议。
	•	需要更“硬”的 techno：把 LIMITS.bpm_soft_range 缩到 126–134，TRANSITION.techno_crossfade_beats 调 24→32。
Phase 7 — 渐进增强（不阻塞主流程）
	•	有空再接：downbeat/phrase 对齐、人声置信度、能量曲线自动提取。
	•	这些在代码里都有 TODO: 标注位置，直接替换函数即可。

2. “联网搜 + 深度思考”结论（Techno 规则 & 可用开源）
通用接歌手法（适配 Techno）
	•	谐波混音 / Camelot 轮：同号或邻号优先；A=小调、B=大调。小调更贴合大多数 techno 质感。Mixed In Key
	•	低频交接（Bass Swap）：避免两首踢/低频叠加引起糊或能量爆炸；在过渡处切走出曲的低频，同时放开入曲低频。Attack Magazine
	•	短语/乐句对齐（Phrase Mixing）：按 16/32 拍边界进入，减少结构冲突。社区与教程都强调“在短语处换低频/掉拍”。Reddit
	•	长时过渡 & 平稳能量：techno 倾向更长的叠放和滤波过渡（24 拍起步），能量曲线平滑爬升。Mixxx/Liquidsoap 等自动化也支持长交叉衰减与自定义 crossfade。manual.mixxx.orgliquidsoap.info
可用开源与可借鉴实现
	•	Mixxx Auto DJ：开源 DJ 软件，提供 AutoDJ、Intro/Outro cue、Key/Beat 检测，可作为行为基线与策略参考。manual.mixxx.orgGitHub
	•	Liquidsoap：电台自动化脚本语言，自带 smart crossfade、自动 cue（含 enable_autocue_metadata()），可脚本化定制过渡逻辑。liquidsoap.info
	•	madmom（Python）下拍/拍点：RNNDownBeatProcessor、DBNDownBeatTrackingProcessor，可直接用于乐句/短语对齐。madmom.readthedocs.io+1
	•	Essentia（C++/Python/JS）Key/HPCP：KeyExtractor（HPCP），也有 danceability 指标，可补充“能量/律动”估计。essentia.upf.edu+1
更新算法/研究动向（可选升级方向）
	•	开源 Automix 系统分析：工程实现与评测（识别关键点、交叉淡入淡出策略），可用于对标与回归测试。
	•	2024+ 数据集/基准：最近的学术工作开始构建 DJ 过渡/自动混音数据与客观评测基准，可供你未来训练/微调模型时使用。
综上，“完全端到端的神经 Automix”在工程上尚不稳定；业界通用做法仍是**“规则（谐波/节奏/能量） + 搜索（beam/graph） + 可选 ML 评分器”**。本次骨架即走这条稳健路线，接口留好，便于你后续把 madmom/Essentia 的输出直接接入打分函数。

3. 给 Cursor 的“傻瓜对接文档”（最少点击）
后端（TS 方案）

# 进入 aidjmix-autoplaylist-api-ts.zip 解压目录
npm i
npm run dev  # 端口 8787
前端

// src/clients/AidjPlaylistClient.ts 复制进去（包里已给）
import { AidjPlaylistClient } from './clients/AidjPlaylistClient';
const client = new AidjPlaylistClient('/api/aidjmix/autoplaylist');

// TODO: tracks = 你的曲库（字段见 TrackFeature）
client.requestAutoPlaylist(tracks, 60, 24);
事件订阅（已有总线就加两行）

UnifiedEventBus.on('automix','plan', (e)=> { /* e.data.m3u 直接给电台 */ });
UnifiedEventBus.on('automix','error',(e)=> { /* toast */ });
变量/环境匹配
	•	端口：PORT=8787
	•	目标时长：TARGET_MINUTES=60
	•	伸缩上限：MAX_STRETCH_PCT=6
	•	Beam 宽度：BEAM_WIDTH=24
详细的“Cursor 一键接入清单”在文档包 CURSOR_CHECKLIST.md。

4. 你给的源码（Manager）怎么“融合但不破坏”
	•	我已在文档包里附了 PATCH_AutoDJ_AutoMix.diff（可选）。这个补丁只新增一个 bindAutoPlaylistClient() 小口子，完全不改变你原来的事件/轮询/状态机。
	•	不打补丁也行：直接在 UI 里触发 AidjPlaylistClient.requestAutoPlaylist(...)，结果仍通过 UnifiedEventBus 广播，与你现有的 emitBpm/emitMood/transition/playback 完全兼容。

5. Techno 专项参数（默认已调好）
	•	BPM 偏好：128±4（软范围 124–136），超出降权。
	•	调性：Camelot 同号>邻号；小调(A)略加分。
	•	能量：出曲尾 vs 入曲头差值越小越好。
	•	过渡：默认 24 拍；自动化建议“出曲高通上移、入曲低频放开”。
	•	人声：vocality 高的曲目降分。（这些权重/阈值都在 config.* 里，一行一行可改。）

搞定，我用你上传的 我的歌单21.m3u8 做了端到端模拟（不改你的接口，只走我们搭好的骨架），按 Techno 偏好自动排了一小时左右的歌单，已经导出三份产物：
	•	下载 M3U8（直接给你的网页电台）
	•	下载 TXT 清单
	•	下载 JSON 过渡计划
我做了什么（最小步骤）：
	1	读取你上传的 .m3u8，解析出路径/标题/时长。
	2	给每首歌填充占位特征（BPM 在 124–132、Camelot 随机在 7–12A/B、固定 8s 入点、末尾 10s 出点），确保和我们评分/编排模块接口对得上。
	3	跑 Beam Search（宽度 16）+ Techno 过渡（默认 24 拍 + 低频交接建议），生成 plan。
	4	导出 m3u8/txt/json 三件套。
接下来两种玩法你选：
	•	马上实战：把 M3U8 直接塞给你的网页电台。如果要“更像你平时的味道”，我把随机的 BPM/Key 替换成你真实的特征即可（字段位都留好了）。
	•	接成 API/按钮：把 AidjPlaylistClient.ts 放到前端，指向我给你的 TS API，就能在页面上一键生成歌单；事件通过 UnifiedEventBus 广播，不动你现有 Manager。
好，直接给你可落地的两件事：① 下载即可用的“Techno 预设”补丁包（含 Python/TS 两套），② 不同速度段的接歌手法 + 在线参考；并把它们都接进你现有核心情绪系统（简单版只做“头尾相接”即可）。
1) 先拿补丁包（含代码 + 打补丁说明）
	•	Techno 预设（Python + TypeScript）：下载 aidjmix-techno-presets.zip
里面有：
	•	aidjmix-autoplaylist-python/aidjmix/presets.py —— Python CLI 预设模块
	•	aidjmix-autoplaylist-api-ts/src/presets.ts —— TS API 预设模块
	•	PATCH_NOTES/ —— 两份极简“怎么改”的贴片说明（不破坏你已有接口）
最小改动（复制粘贴式）：
	•	Python：在 cli.py 里加 --preset 与 --simple_head_tail，并 from .presets import apply_preset; apply_preset(args.preset)；把 plan_transitions(..., simple_head_tail=args.simple_head_tail) 传进去（transitions.py 签名多一个 simple_head_tail: bool=False，为真时只做“头尾相接”，不加滤波自动化）。
	•	TS API：server.ts 接受 preset 与 simpleHeadTail，applyPreset(preset) 后 planTransitions(seq, true, simpleHeadTail)；transitions.ts 同样加第三参，simpleHeadTail=true 时仅 head→tail 对齐。
这俩改动都在补丁包的 PATCH_NOTES/ 里逐行写好了，Cursor 直接照做。

2) 不同速度的 Techno 预设（带手法）
以下每个预设我都已经写进代码（见上方补丁包），数值来自社区常识与权威入门资料的交叉范围；你可以再微调。
deep_minimal（慢速/极简 122–126）
	•	BPM 范围：122–126（理想 124）
	•	过渡：32 拍长层叠；“头尾相接”（simple_head_tail=true 时仅在尾/头衔接）
	•	EQ 手法：慢速低频交接（先杀出曲低频→放入曲低频），轻滤波推进
	•	权重：人声更讨厌（vocal↑），能量权重略低（保持流动）
	•	参考：Techno 通常 120–140/150 BPM；Deep/Dub/Minimal 的低速段见多来源统计。learningmusic.ableton.comZIPDJ | The World's Best DJ PoolTechno Airlines
classic（俱乐部常速 126–130）——默认
	•	BPM：126–130（理想 128）
	•	过渡：24 拍；低频交接 + 谐波混音（Camelot 同号/邻号）
	•	EQ 手法：先淡出出曲低频，入曲上来再逐步放低频（避免双踢相位冲突） DJ.Studio | The Ultimate DAW for DJsReddit+1
	•	调性：A=小调、B=大调；同号>邻号>相对调（已在算法里加小调轻权重） DJ.Studio | The Ultimate DAW for DJsMixed In Key
peak_warehouse（峰值/仓库 128–134）
	•	BPM：128–134（理想 130）
	•	过渡：24 拍；短语边界切换（16/32 拍处），能量小幅上扬
	•	EQ 手法：低频交接更快，允许更紧凑的高频/帽子叠放维持能量 Reddit
hard_techno（硬核 140–150）
	•	BPM：140–150（理想 145）
	•	过渡：短（8–12 拍）；果断的 bass kill → swap（或干脆切）
	•	编排：允许更短曲时长与快速段落变化；tempo/energy 权重更高 EDMProd
hypnotic（催眠 130–134）
	•	BPM：130–134（理想 132）
	•	过渡：超长 32 拍层叠；能量更平，注重纹理与循环
	•	EQ 手法：轻滤波，尽量减少突兀元素切换（贴合 hypnotic 流派的“流动感”）

3) 和核心情绪系统对接（简单版）
你之前的核心是 UnifiedEventBus + UnifiedCore。我们这次不改变你的接口，只在生成 plan 时，把“段落/强度”映射为一个极简情绪钩子：
	•	当 simpleHeadTail=true：
	◦	在每次过渡的最后 2 拍触发：emitMood({ energy: energy+0.05, arousal: arousal+0.03 })（轻微上扬）
	◦	新曲开始后 第 1 拍回落：emitMood({ energy: baseline, arousal: baseline })
	•	这两处钩子不会影响你现有 AutoMixManager 的步进逻辑，只是给它“知道有过渡了”的信号。
如果你愿意，我可以把这两行事件钩子加到 AidjPlaylistClient 成功回调后，或者在 AutoDJManager 里监听 automix:plan 自动广播。保持“能跑就行”的简单度。

4) .env / 配置建议（直接可复制）
TS API

PORT=8787
TARGET_MINUTES=60
MAX_STRETCH_PCT=6
BEAM_WIDTH=24
	•	运行时可在 body 里传：preset（如 deep_minimal / classic / peak_warehouse / hard_techno / hypnotic）、simpleHeadTail（布尔）。
Python CLI

# 用参数更直观：
python -m aidjmix.cli your_features.json out/ --minutes 60 --beam 24 --techno 1 --preset classic --simple_head_tail

5) 你要的“最基本接歌手法”（用于预设说明/训练新人）
	•	谐波混音：Camelot 同号或邻号（A=小调，B=大调）。DJ.Studio | The Ultimate DAW for DJsMixed In Key
	•	短语对齐：在 16/32 拍的段落边界进/出，避免结构冲突。Reddit
	•	低频交接（Bass Swap）：先削出曲低频→放入曲低频，防止两只踢鼓抢占同一频段。DJ.Studio | The Ultimate DAW for DJsReddit+1
	•	能量/情绪：保持平滑爬升，硬核可允许更陡。通用 BPM 范围参考：Techno 120–140/150；子风格分布见多来源。learningmusic.ableton.comZIPDJ | The World's Best DJ PoolTechno Airlines

要不要我把补丁直接打进你之前的四个包（Python/TS/前端桥接/文档）再生成一套“合并版下载”？或者你先挑一个预设（比如 peak_warehouse）让我用你同一份曲库 再模拟一次，这回启用 simpleHeadTail=true，看看效果。

给你做好了：我在参考你上传的 WebUI（纯前端） 的基础上，抽取了你的美术风格（调色盘/材质倾向），并把命令台式的前端骨架升级成「DJ Pro 信息密度 + 太空银 Space Silver 主题 + 底部抽屉（SYNC弹出）+ 接入你 automix 事件总线」的可直接接入版。全部文件已打包：
	•	下载骨架包：aidj-console-silver-theme.zip
里面都帮你排列好了，专门给 Cursor “填 UI”的：
	•	src/console/AIDJConsoleSkeleton.tsx只保留结构与逻辑，不做渲染。挂在电台播放器下方；点击 SYNC → 自下边缘弹出 Bottom Sheet 命令台。区块占位：台站状态、情绪核心（energy/valence/arousal 实时）、NowPlaying、控制区（Preset/Technique/SimpleHeadTail/Generate）、快速反馈、过渡日志。事件总线对齐你的 automix 命名：onMood/onBpm/onTransition/onPreset/onPlan 已接好。
	•	src/console/EventBusAdapter.ts总线适配器占位：把这里的 on/off/emit 替换成你项目里的 UnifiedEventBus 即可（命名一一对应）。我已提供 onMood/onBpm/onTransition/onPreset/onPlan 的便捷封装，零侵入接你 AutoDJManager/AutoMixManager。
	•	src/clients/AidjPlaylistClient.ts请求自动歌单（不改你原接口）并广播 automix:plan / automix:error；支持 preset、simpleHeadTail、technique，并内置乐观反馈：点击就先广播 automix:request，UI能立刻给“AI在工作”的感。
	•	src/console/ConsoleStore.tsZustand 状态（panel 三态：hidden/peeking/open；preset/technique/simpleHeadTail；emotion/radio/now/plan）。
	•	src/console/SpaceSilverTokens.css太空银主题 Token：我基于你 WebUI 的调色盘抽取，预置了：--chrome / --chrome-2（金属银）、--deep-space（深空蓝黑）、--glass-light / --glass-dark（毛玻璃层）、以及多档白色透明度。TODO 已写明：Cursor 用 Tailwind/shadcn/ui/framer-motion 把这些变量映射到真实样式（拉丝金属+毛玻璃+霓虹指示）。
	•	src/style/USER_STYLE_GUIDE.md + src/style/USER_STYLE_TOKENS.json + ART_STYLE_TAGS.md我从你上传的 WebUI 自动抽取了高频颜色（如 #c0c5ce / #a8b2c4 银色、#030213 深空底色、#ffffff1a/#0000001a 玻璃层等），并把艺术风格标签落到了文档里：
	◦	空间银（金属拉丝 + 冷色高光）
	◦	深空蓝黑 + 细网格/星尘粒子
	◦	毛玻璃层（轻透明白/黑叠加）
	◦	霓虹指示（蓝青/薄荷）强调“AI响应”
	◦	极简但信息密度高，参考 DJ Pro 控台这三份文件方便你或 Cursor 微调视觉与 Token。
	•	src/types/shared.ts统一类型（PresetName/TechniqueName/EmotionState/RadioParams/NowPlaying/AutoPlanMeta 等），与后端契约一致。
	•	README.md一页式集成说明（怎么接总线、怎么贴在电台下面、Cursor 要填的 UI TODO 清单）。

怎么“酷一点 & 有反馈”
我在骨架里预留了这些快速反馈钩子（都写了 TODO 标注，Cursor 填 UI 即可）：
	•	SYNC 浮动按钮（银色霓虹，贴在电台右下）→ 打开 Bottom Sheet。
	•	点 Generate 立刻 emit(automix:request) → UI 可显示“AI 正在编排中”的霓虹进度条/脉冲条；返回 automix:plan 时高亮 OK 指示，并在日志区插入一条“编排完成”的记录。
	•	切换 preset/technique/simpleHeadTail 即改 Store，立即视觉响应（例如给 preset 标签做霓虹闪烁）。

与你 automix 源码的对接点（零侵入）
	1	事件总线：把 EventBusAdapter.ts 的占位换成你的 UnifiedEventBus。
	2	管理器事件：onPreset/onMood/onBpm/onTransition/onPlan 已订阅；收到后更新 Store → UI 自刷新。
	3	按钮动作：AidjPlaylistClient.requestAutoPlaylist(tracks, { preset, simpleHeadTail, technique })；你只需把 tracks 换成真实曲库（保留我们约定的字段），不动后端端口即可。


OK，全部按你最新要求重做了一版：在参考你上传的 WebUI 基础上，标注了你的美术风格，把我们之前的逻辑、接口、事件、轮换策略、Cursor 待办清单、接线指南都系统化，并且升级前端骨架（只写结构、不做渲染）让它贴在电台下面、点 SYNC 从下边缘弹出、实时接你的 automix 事件。所有文件已重新生成并打包：
	•	下载（v2 合集）：aidj-console-silver-theme-v2.zip
里面包含你要的全部清单、接口、备注（给 Cursor 的“大堆注释”我已经写满）：
代码骨架（可直接接）
	•	src/console/AIDJConsoleSkeleton.tsx —— 命令台骨架（Bottom Sheet；点击 SYNC 弹出；键盘 S/G；实时接 mood/bpm/transition/preset/plan）。
	•	src/console/EventBusAdapter.ts —— 默认内存事件总线（即插即用）；src/console/EventBusAdapter.unified.ts —— 你的 UnifiedEventBus 专用映射模板（把方法名替换成你的即可）。
	•	src/clients/AidjPlaylistClient.ts —— 请求自动歌单（携带 preset / simpleHeadTail / technique；乐观反馈：立刻发 automix:request）。
	•	src/console/ConsoleStore.ts —— Zustand 状态（panel 三态、preset/technique/simpleHeadTail、emotion/radio/now/plan）。
	•	src/console/SpaceSilverTokens.css —— 太空银主题 Token（金属银/深空底/毛玻璃层/白色透明度）。
	•	rotation/presetScheduler.ts —— 逻辑-only 的预设轮换（时间段 + Telemetry 简化开关）。
	•	demo/AppStub.tsx —— 挂载示例（贴在电台播放器下面，仅占位不渲染）。
设计与风格标注（源自你的 WebUI）
	•	src/style/USER_STYLE_TOKENS.json、src/style/USER_STYLE_GUIDE.md、src/style/ART_STYLE_TAGS.md
	◦	抽取并标注了你的银色系调色盘（如 #c0c5ce / #a8b2c4）、深空底色（#030213）、玻璃层（#ffffff1a / #0000001a）等；
	◦	“空间银 Space Silver + 深空 + 毛玻璃 + 霓虹反馈 + DJ Pro 信息密度”的审美标签全部落在文档里，方便 Cursor 复制粘贴到 Tailwind/shadcn。
面向 Cursor 的全量文档
	•	docs/INTERFACES.md —— 接口/事件/负载（REST Body、TrackFeature、事件 payload 完整列出）。
	•	docs/WIRING_GUIDE.md —— 总线接线指南（怎么把适配器换成你的 UnifiedEventBus，两种方案）。
	•	docs/CURSOR_TASKS.md —— UI 待办清单（P0/P1/P2、每项带验收标准，含“AI 正在工作”反馈）。
	•	docs/CHECKLIST.md —— 集成核对表（一步步走，防漏项）。
	•	docs/EVENT_MATRIX.md —— 事件流矩阵（谁发谁收、字段一目了然）。
	•	docs/STYLE_GUIDE.md —— 空间银主题落地建议（Tailwind/shadcn/ui/framer-motion 使用建议）。
	•	docs/API_MOCKS.http —— HTTP 示例请求（无端口、仅占位路径，保留你现有后端）。
	•	docs/GLOSSARY.md —— 术语表。
	•	docs/CHANGELOG.md —— 更新记录。
	•	docs/CONVERSATION_SUMMARY.md —— 我们对话的要点回顾（让 Cursor 一眼明白“为什么这样做”）。

你接下来只需三步
	1	把 EventBusAdapter.ts 换成 EventBusAdapter.unified.ts 里示例的真实映射（指向你的 UnifiedEventBus）。
	2	把 <AIDJConsoleSkeleton /> 放到电台播放器下面（demo 里有挂载示例）。
	3	在 actionSyncGenerate() 里把 tracks=[] 换成你的曲库（字段按 TrackFeature）。
所有视觉/动画都已经写成 TODO(Cursor)：
	•	SYNC 银色霓虹按钮 → bottom sheet 弹出（framer-motion）；
	•	“AI 正在编排中”脉冲条/呼吸灯；完成后绿色 OK 灯；
	•	情绪核心数字/条形、日志滚动、预设短闪动、Technique 单选、SimpleHeadTail 开关等。
需要我把你项目里 UnifiedEventBus 的真实方法名直接写进 EventBusAdapter.unified.ts 吗？把函数签名贴我就可以进一步给你“强绑定版”，省去 Cursor 改名这一步。


下面这份就是你要的「项目配置文档 + 特别注意事项」。我把你给的 AutoDJManager / AutoMixManager、事件总线、情绪映射、Techno 预设与轮换、前端骨架（SYNC 底部抽屉）全部串起来，给出可落地的配置、接线、参数边界与避坑清单。不改你的端口，只写逻辑与对接点。

项目配置文档（AIDJ · 空间银命令台）
0. 总览（一句话原则）
	•	前端只做“命令台壳子”：显示电台参数、情绪核心实时选择、预设与接歌手法切换；点击 SYNC 自底部弹出；所有渲染交给 Cursor 完成。
	•	与现有管线零侵入：只通过你的 UnifiedEventBus 订阅 mood/bpm/transition/preset/plan，以及发送 request 等事件；不改 AutoDJManager / AutoMixManager。
	•	稳定第一：默认启用 simpleHeadTail（仅头尾相接）作为退路；用预设轮换+乐观反馈（点击就亮灯）保证“AI 很快有反应”。

1. 目录与关键文件（前端骨架）
你已经拿到的 zip（v2）里，对应这些路径。Cursor 只需“填 UI”。
src/
  types/shared.ts                 # 统一协议类型（Preset/Technique/Emotion/...）
  console/
    AIDJConsoleSkeleton.tsx       # 命令台骨架（Bottom Sheet，SYNC 弹出）
    ConsoleStore.ts               # Zustand 状态（panel/preset/technique/simpleHeadTail/...）
    EventBusAdapter.ts            # 默认内存总线（可直接跑）
    EventBusAdapter.unified.ts    # ★替换模板：接你的 UnifiedEventBus（推荐用这份）
    SpaceSilverTokens.css         # 空间银主题变量（银色/深空/玻璃层/霓虹）
  clients/
    AidjPlaylistClient.ts         # 自动歌单请求客户端（乐观广播 automix:request）
rotation/
  presetScheduler.ts              # 预设轮换（逻辑-only；24h 稳定）
docs/
  INTERFACES.md                   # 接口/事件/负载结构
  WIRING_GUIDE.md                 # ★总线接线指南（怎么换成 UnifiedEventBus）
  CURSOR_TASKS.md                 # UI 待办清单 + 验收标准
  CHECKLIST.md                    # 集成核对表
  EVENT_MATRIX.md                 # 事件流矩阵
  STYLE_GUIDE.md                  # 空间银主题落地法
  API_MOCKS.http                  # HTTP 请求示例（占位路径）
  CONVERSATION_SUMMARY.md         # 我们对话要点（意图与边界）
style/
  USER_STYLE_TOKENS.json          # 从你 WebUI 抽取的调色盘（供 Cursor 对色）
  USER_STYLE_GUIDE.md             # 你的美术风格标注
  ART_STYLE_TAGS.md               # 空间银/深空/霓虹 等风格标签

2. 环境与依赖（建议）
	•	Node ≥ 18；TypeScript ≥ 5；包管理器：pnpm/yarn/npm 均可
	•	UI 基建（Cursor 去装）：tailwindcss, framer-motion, lucide-react, @radix-ui/react-* 或 shadcn/ui
	•	状态：zustand
	•	构建：随你，Vite 或 Next.js 都可（下面给两套最简命令）
Vite（推荐做单页壳子）
pnpm add react react-dom zustand
pnpm add -D typescript vite @types/react @types/react-dom
# UI & 动效
pnpm add tailwindcss framer-motion lucide-react
Next.js（如果你电台页面已是 Next）
pnpm create next-app@latest
pnpm add zustand tailwindcss framer-motion lucide-react
# SSR 注意：命令台组件在客户端渲染（'use client'），避免 SSR 时访问 window。

3. 运行时配置（.env 建议项）
不新增端口，只是把可变参数集中化；前端通过 import.meta.env 或 process.env 读取。
变量名
建议值
作用
备注
VITE_API_BASE
/
API 基础路径
前端 fetch 用，不改端口
VITE_AUTODJ_POLL_MS
2000
/api/autodj/status 轮询间隔
要与 AutoDJManager 对齐
VITE_NOWPLAYING_POLL_MS
5000
/api/nowplaying 间隔
要与 AutoMixManager 对齐
VITE_BEAM_WIDTH
24
beam search 宽度默认
前端提交给后端
VITE_TARGET_MINUTES
60
目标时长
同上
VITE_DEFAULT_PRESET
classic
启动预设
与轮换策略互动
VITE_TIMEZONE
Asia/Bangkok
轮换的时区基准
你的时区（重点）

4. 与现有源码的最小对接点
4.1 事件总线（必须）
	•	你已有：UnifiedEventBus（示例：emitBpm, emitMood, emitPreset, 以及通用 emit）
	•	我们需要：把 src/console/EventBusAdapter.unified.ts 的占位，映射到你的真实方法名即可
	◦	订阅：on(ns, type, cb)（或你的 onXxx）
	◦	广播：emit({ namespace, type, data, timestamp })
	•	必须保证的命名空间/事件（与代码对齐）：
	◦	automix:mood → { mood: { energy, valence, arousal } }
	◦	automix:bpm → { bpm }
	◦	automix:transition → { action, fromTrack, toTrack, index }
	◦	visualization:preset → { name }
	◦	automix:plan → { plan, m3u, txt }
	◦	automix:request（前端发）→ { minutes, beamWidth, preset, simpleHeadTail, technique }
4.2 你的管理器（不改，只要按它的节奏走）
	•	AutoDJManager
	◦	每 2s 拉 /api/autodj/status；曲目切换时 emit transition + emitPlayback('play')
	◦	deriveMoodFromBpmKey(bpm, key) → 能量/情绪基线（注意：B 调性 +0.06 valence，A 调性 -0.05）
	•	AutoMixManager
	◦	每 5s 拉 /api/nowplaying；每 500ms tickCore() 推进核心
	◦	产生新 presetId 时 emitPreset(name)；广播完整 visualization:effect（可用于更炫的 UI）
特别注意（你这两段代码的稳定点 / 改良边界）：
	•	不要重复创建定时器（只保留单例）；dispose() 要把 unsubscribes 和 interval 清干净
	•	emitBpm 频率受节流保护（良好）；前端不要再二次高频广播
	•	deriveAudioFeatures 是“无分析器保底策略”，前端 UI 展示为估计值，避免误导
	•	mapPresetToName 与前端显示保持同名，避免 preset 标签跳变

5. 控制台模块（命令台）—— 功能与数据契约
	•	位置：电台播放器下方；点击 SYNC → 自底部弹出
	•	数据（Zustand ConsoleStore 已准备）：
	◦	radio：stationName/uptimeSec/listeners/dropoutRate/avgBpm
	◦	emotion：energy/valence/arousal/preset
	◦	now：title/artist/bpm/keyCamelot/segment
	◦	plan：count/minutes/preset/technique
	◦	preset/technique/simpleHeadTail：用户可切换
	•	动作：
	◦	actionSyncGenerate()：发送 automix:request → 后端生成 → 收 automix:plan
	◦	actionApplyPreset/Technique/ToggleSimple()：本地变更 +（可选）广播提示
	•	用户体验（强制）：
	◦	点击即乐观反馈：发出 automix:request → 立刻显示“AI 正在编排中”霓虹进度
	◦	收到 automix:plan → OK 灯高亮 + 日志插入“完成”记录
	◦	键盘：S 开关抽屉，G 触发生成

6. 预设 / 接歌手法 / 轮换（参数与边界）
6.1 预设（5 套，覆盖 122–150 BPM）
预设
区间
重点
过渡建议
deep_minimal
122–126
极简/低声
32 拍长层叠
classic
126–130
万能稳态
24 拍 crossfade + 低频交接
peak_warehouse
128–134
峰值推进
短语边界切换
hard_techno
140–150
冲击/快速
8–12 拍，bass kill→swap
hypnotic
130–134
纹理/流动
32 拍超长层叠
稳定优先：当 dropoutRate > 5%、或 recentErrors > 0，自动简化为 simpleHeadTail=true。
6.2 手法（Technique）
	•	bass_swap（默认低频交接）
	•	long_layer_24（慢速时 24 拍层叠）
	•	phrase_cut_16（快速时 16 拍果断切）
	•	simple_head_tail（仅头尾相接；你的兜底）
6.3 轮换（rotation/presetScheduler.ts）
	•	时区：默认 Asia/Bangkok（建议从 .env 注入）
	•	默认表：00–06 deep_minimal → 06–12 classic → 12–22 peak_warehouse → 22–24 hypnotic
	•	Telemetry 影响：
	◦	avgBpm ≥ 132 且当前偏“柔”：上调到 peak_warehouse
	◦	avgBpm ≤ 126 且当前偏“硬”：回落到 classic
	◦	dropoutRate > 5% 或 recentErrors > 0：强制 simpleHeadTail=true

7. 情绪核心映射（与你的实现对齐）
	•	energy / arousal：从 BPM（90–150）线性映射（你代码里：energy=0.2..0.95，arousal=0.25..0.9）
	•	valence：Camelot B（大调）+0.06，A（小调）-0.05
	•	前端展示建议：标注“估计值 / 来自 BPM+Key 推导”；避免误导为“音频频域分析结果”

8. 性能与稳定性（极重要）
	1	单例定时器：命令台挂载/卸载不可重复创建拉取循环（Manager 已处理，你的页面层也要避免重复挂载）。
	2	事件节流：BPM/情绪事件不要超过 10Hz；前端不要把后端来的事件再高频广播回去。
	3	错误与降级：
	◦	/api/autodj/status 或 /api/nowplaying 异常 → UI 仍可用（按钮不禁用，保留 simpleHeadTail 兜底）
	◦	automix:plan 失败 → 红色错误条，但不关闭抽屉（允许用户再次点击）
	4	多标签页竞争：同一账号开多标签会多次请求：
	◦	建议在前端缓存“最近一次请求时间”，距离 < 3s 则合并（防抖）
	5	移动端：Bottom Sheet 占全宽；限制阴影/模糊层次数量，防止掉帧

9. 安全与边界
	•	绝不信任 track path（来自 m3u/txt/外部）：UI 不显示原始磁盘路径；以 “Artist - Title” 为主。
	•	CORS/凭据：前端只走你现有域；不要在页面里嵌入明文 token。
	•	日志脱敏：listeners 等只显示数量；不要上报单个用户信息。
	•	防 DoS：按钮有防抖；每次只保留最后一次进行中的请求（中止旧的 fetch）。

10. 测试与验收（最少清单）
	•	事件回路：手动广播 onMood/onBpm/onTransition/onPreset/onPlan，UI 全能动（无后端也可）。
	•	请求闭环：点击 Generate → 立刻出现“AI 正在编排中” → 收到 plan → OK 高亮 + 日志一行“完成”。
	•	切换控件：Preset/Technique/simpleHeadTail 本地状态立即变化；再次 Generate 时参数正确带上。
	•	长稳运行：12 小时演示（开发环境），确认内存稳定、没有事件泄漏。

11. 常见坑（踩过的都写上）
	•	重复订阅：useEffect 里订阅总线后没 off() 清理，导致日志重复；务必按我骨架里的 unsub 模式写。
	•	plan 的 items 可能为空（曲库不合法或后端筛选失败）；UI 要能显示“无可用结果”。
	•	NaN/undefined：bpm/key/duration 缺失时一定要有占位（你后端现在也做了保底）。
	•	主题变量未映射：SpaceSilverTokens.css 只是变量；Cursor 若不把变量挂到 Tailwind 配置，就“没效果”。

12. 与服务器/自动化的关系（给运营同学的两点）
	•	你当前路径是前端命令台 + 现有后端（aidjmix/beam search）；这条链完全可以在云上长稳跑 24h。
	•	如果要远程调用 DJ.Studio（mac 版）：建议独立 Mac mini + launchd 定时跑 AppleScript/快捷指令，HTTP 只做触发；不要把这件事掺进网页端口里（故障域要隔离）。

13. 不该改的部分（强约束）
	•	AutoDJManager / AutoMixManager 的事件名与节奏（2s/5s/500ms）
	•	preset 的五个字符串与语义
	•	simpleHeadTail=true 的兜底语义（只接头尾；不做滤波自动化）
	•	TrackFeature 的最小字段：id, durationSec, bpm, keyCamelot, path

14. 最简“接线清单”（抄表即用）
	1	用 EventBusAdapter.unified.ts 映射到你的 UnifiedEventBus：
	◦	on('automix','mood'|bpm|transition|plan)
	◦	on('visualization','preset')
	◦	emit({ namespace:'automix', type:'request' })
	2	在电台页面：// 你的播放器…
	3	<AIDJConsoleSkeleton />
	4	// SYNC 按钮 + Bottom Sheet 动画交给 Cursor（参见 CURSOR_TASKS.md）
	5	
	6	给 AidjPlaylistClient.requestAutoPlaylist(tracks, { preset, simpleHeadTail, technique }) 填真实 tracks。
	7	.env 写上 VITE_TIMEZONE=Asia/Bangkok（轮换按泰国时间跑）。
	8	验收：点击 SYNC → Generate，立刻有“AI 正在编排”的视觉反馈；数秒后 plan 到达，OK 灯亮。

15. 结论（直白）
	•	你现在这套五预设 + 轮换 + simpleHeadTail 兜底，已经够24h 不间断稳态。
	•	前端命令台不要思考“怎么混”，只要把“AI在做事”的反馈做到极致，就能立刻显得高级。
	•	真正的风险点只有三个：重复订阅、高频事件回流、无兜底的失败态。我在骨架里全挡住了：unsub、节流、simpleHeadTail。

需要我把这份文档存成 PROJECT_SETUP.md 并放进你那个 v2 包里吗？如果要，我现在就补进去并给你新的下载链接。

