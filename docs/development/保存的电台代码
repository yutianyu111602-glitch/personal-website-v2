import React, { useState, useEffect, useRef, useCallback } from "react";
import { motion } from "motion/react";
import { getTranslations } from "./util/i18n";
import WaveSurfer from "wavesurfer.js";
import { UnifiedEventBus, onPlayback, onTransition } from "./components/events/UnifiedEventBus";

interface TiangongRadioPlayerProps {
  language: string;
  syncActive?: boolean;
  onSyncToggle?: () => void;
  onClose?: () => void;
  autoPlayOnMount?: boolean;
  preloadOnly?: boolean;
}

// éŸ³é¢‘æ–‡ä»¶æ¥å£ - é€‚é…V2ç‰ˆæœ¬APIè·¯ç”±
interface AudioTrack {
  id: string;
  title: string;
  artist: string;
  duration: number;
  bpm: number;
  key?: string;
  genre?: string;
  path?: string;
  type: string;
  playCount: number;
}

// å¸é™„è¾¹ç¼˜æšä¸¾
enum SnapEdge {
  None = 'none',
  Left = 'left',
  Right = 'right',
  Top = 'top',
  Bottom = 'bottom'
}

// å¸é™„çŠ¶æ€æšä¸¾
enum SnapState {
  Free = 'free',       // è‡ªç”±çŠ¶æ€ï¼Œæœªå¸é™„
  Snapped = 'snapped', // å·²å¸é™„åˆ°è¾¹ç¼˜
  Expanded = 'expanded' // ä»å¸é™„çŠ¶æ€å±•å¼€
}

/**
 * å¤©å®«ç”µå°æ’­æ”¾å™¨ - V2ç‰ˆæœ¬é‡æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰
 * 
 * æ ¸å¿ƒç‰¹æ€§ï¼š
 * - ğŸ¯ ç®€åŒ–äº¤äº’ç³»ç»Ÿ - ç”¨æŒ‰é’®æ›¿ä»£æ‹–æ‹½
 * - ğŸ§² æ™ºèƒ½è¾¹ç¼˜å¸é™„ - è‡ªåŠ¨æ£€æµ‹æœ€è¿‘è¾¹ç¼˜
 * - ğŸ‘† ä¸€é”®åˆ‡æ¢çŠ¶æ€ - å¸é™„/å±•å¼€/è‡ªç”±çŠ¶æ€å¾ªç¯
 * - ğŸ¬ æµç•…åŠ¨ç”»è¿‡æ¸¡ - çŠ¶æ€é—´å¹³æ»‘åˆ‡æ¢
 * - ğŸ“ ä½ç½®è®°å¿† - è®°ä½ç”¨æˆ·åå¥½ä½ç½®
 * - ğŸµ åŸºç¡€æ’­æ”¾åŠŸèƒ½ - æ’­æ”¾/æš‚åœã€éŸ³é‡æ§åˆ¶ã€åŒæ­¥
 * - ğŸ“œ æ»šåŠ¨é€‚é… - å¸é™„çŠ¶æ€ä¸‹ä¸å—é¡µé¢æ»šåŠ¨å½±å“
 * - ğŸ¼ æµ‹è¯•æ¨¡å¼ - ç¡¬ç¼–ç éŸ³ä¹ç›®å½•ï¼Œæœ¬åœ°æµ‹è¯•
 * - ğŸ”„ äº‹ä»¶ç³»ç»Ÿé›†æˆ - ä¸V2ç‰ˆæœ¬æƒ…ç»ªæ ¸å¿ƒå®Œå…¨å…¼å®¹
 */
export const TiangongRadioPlayer: React.FC<TiangongRadioPlayerProps> = ({
  language,
  syncActive = false,
  onSyncToggle,
  onClose,
  autoPlayOnMount = false,
  preloadOnly = false
}) => {
  // ğŸ¯ ä½ç½®å’ŒçŠ¶æ€ç®¡ç†
  const [position, setPosition] = useState({
    x: 20,
    y: Math.max(20, window.innerHeight - 300)
  });
  
  // ğŸ§² å¸é™„ç³»ç»ŸçŠ¶æ€
  const [snapState, setSnapState] = useState<SnapState>(SnapState.Free);
  const [snappedEdge, setSnappedEdge] = useState<SnapEdge>(SnapEdge.None);
  const [freePosition, setFreePosition] = useState({ x: 20, y: window.innerHeight - 280 - 20 });
  
  // ğŸµ æ’­æ”¾çŠ¶æ€
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(0.6);
  const [waveformReady, setWaveformReady] = useState(false);
  const [currentTrack, setCurrentTrack] = useState<AudioTrack | null>(null);
  const [audioDuration, setAudioDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  
  // ğŸ¼ éŸ³é¢‘æ–‡ä»¶ç®¡ç†
  const [audioFiles, setAudioFiles] = useState<AudioTrack[]>([]);
  const [currentTrackIndex, setCurrentTrackIndex] = useState(0);
  
  // ğŸ“Š V2ç‰ˆæœ¬APIçŠ¶æ€
  const [isLoading, setIsLoading] = useState(false);
  const [streamUrl, setStreamUrl] = useState<string | null>(null);
  
  // å¼•ç”¨
  const playerRef = useRef<HTMLDivElement>(null);
  const waveformRef = useRef<HTMLDivElement>(null);
  const wavesurferRef = useRef<WaveSurfer | null>(null);
  const audioRef = useRef<HTMLAudioElement>(null);
  
  // ğŸ•’ è‡ªåŠ¨å¸é™„å®šæ—¶å™¨
  const [autoSnapTimer, setAutoSnapTimer] = useState<NodeJS.Timeout | null>(null);
  
  // ğŸ”„ é‡è¿å®šæ—¶å™¨
  const reconnectTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // ğŸµ è‡ªåŠ¨æ’­æ”¾å‡†å¤‡
  const autoplayArmedRef = useRef(true);
  
  const t = getTranslations(language);

  // âœ… è‡ªé€‚åº”çª—å£å°ºå¯¸ï¼ˆä¿®å¤UIæ¯”ä¾‹é—®é¢˜ï¼‰
  const getPlayerDimensions = useCallback(() => {
    // ä½¿ç”¨è§†å£æ¯”ä¾‹å¹¶é™åˆ¶ä¸Šä¸‹ç•Œï¼Œä¿è¯åœ¨ä¸åŒå±å¹•ä¸‹æ¯”ä¾‹åˆç†
    const width = Math.min(420, Math.max(280, Math.round(window.innerWidth * 0.34)));
    const height = Math.min(340, Math.max(220, Math.round(window.innerHeight * 0.28)));
    return { width, height };
  }, []);

  const [playerDims, setPlayerDims] = useState(() => getPlayerDimensions());

  // ğŸ§² æ™ºèƒ½è¾¹ç¼˜æ£€æµ‹ - æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„è¾¹ç¼˜
  const findNearestEdge = useCallback((x: number, y: number) => {
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // ä»…åŒ…å«å¯å¸é™„çš„å››ä¸ªè¾¹ï¼ˆä¸å« noneï¼‰
    type EdgeKey = Exclude<SnapEdge, SnapEdge.None>;
    const distances: Record<EdgeKey, number> = {
      left: x,
      right: viewportWidth - x - playerDims.width,
      top: y,
      bottom: viewportHeight - y - playerDims.height
    };

    // æ‰¾åˆ°è·ç¦»æœ€çŸ­çš„è¾¹ç¼˜
    const nearestEdge = (Object.keys(distances) as EdgeKey[]).reduce((closest, edge) => {
      return distances[edge] < distances[closest] ? edge : closest;
    });

    // è®¡ç®—å¸é™„ä½ç½®
    const snapPositions: Record<EdgeKey, { x: number; y: number }> = {
      left: { x: 0, y: Math.max(50, Math.min(viewportHeight - 150, y)) },
      // å³ä¾§å¸é™„ï¼šä½¿ç”¨20pxæçª„æ¡ï¼Œä¸å—ç»„ä»¶å®½åº¦å½±å“
      right: { x: viewportWidth - 20, y: Math.max(50, Math.min(viewportHeight - 150, y)) },
      top: { x: Math.max(50, Math.min(viewportWidth - 150, x)), y: 0 },
      bottom: { x: Math.max(50, Math.min(viewportWidth - 150, x)), y: viewportHeight - 20 }
    };

    return {
      edge: nearestEdge,
      position: snapPositions[nearestEdge]
    };
  }, [playerDims.width, playerDims.height]);

  // ğŸ“ è·å–å±•å¼€ä½ç½®
  const getExpandedPosition = useCallback(() => {
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    switch (snappedEdge) {
      case SnapEdge.Left:
        return { x: 20, y: Math.max(20, Math.min(viewportHeight - (playerDims.height + 20), freePosition.y)) };
      case SnapEdge.Right:
        return { x: viewportWidth - (playerDims.width + 20), y: Math.max(20, Math.min(viewportHeight - (playerDims.height + 20), freePosition.y)) };
      case SnapEdge.Top:
        return { x: Math.max(20, Math.min(viewportWidth - (playerDims.width + 20), freePosition.x)), y: 20 };
      case SnapEdge.Bottom:
        return { x: Math.max(20, Math.min(viewportWidth - (playerDims.width + 20), freePosition.x)), y: viewportHeight - (playerDims.height + 20) };
      default:
        return freePosition;
    }
  }, [snappedEdge, freePosition, playerDims.height, playerDims.width]);

  // ğŸ¯ å¸é™„æŒ‰é’®ç‚¹å‡»å¤„ç†
  const handleSnapToggle = useCallback(() => {
    switch (snapState) {
      case SnapState.Free:
        // è‡ªç”±çŠ¶æ€ â†’ å¸é™„çŠ¶æ€
        const { edge, position: snapPos } = findNearestEdge(position.x, position.y);
        setFreePosition(position); // ä¿å­˜å½“å‰è‡ªç”±ä½ç½®
        setSnappedEdge(edge);
        setPosition(snapPos);
        setSnapState(SnapState.Snapped);
        console.log(`ğŸ§² å¸é™„åˆ°${edge}è¾¹ç¼˜`);
        break;
        
      case SnapState.Snapped:
        // å¸é™„çŠ¶æ€ â†’ å±•å¼€çŠ¶æ€
        const expandPos = getExpandedPosition();
        setPosition(expandPos);
        setSnapState(SnapState.Expanded);
        console.log(`ğŸ“– å±•å¼€çª—å£`);
        break;
        
      case SnapState.Expanded:
        // å±•å¼€çŠ¶æ€ â†’ è‡ªç”±çŠ¶æ€
        setPosition(freePosition);
        setSnappedEdge(SnapEdge.None);
        setSnapState(SnapState.Free);
        console.log(`ğŸ†“ æ¢å¤è‡ªç”±çŠ¶æ€`);
        break;
    }
  }, [snapState, position, findNearestEdge, getExpandedPosition, freePosition]);

  // ğŸ“ çª—å£å¤§å°å˜åŒ–å¤„ç†
  useEffect(() => {
    const handleResize = () => {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      if (snapState === SnapState.Snapped) {
        // é‡æ–°è®¡ç®—å¸é™„ä½ç½®
        const { position: newSnapPos } = findNearestEdge(freePosition.x, freePosition.y);
        setPosition(newSnapPos);
      } else if (snapState === SnapState.Expanded) {
        // é‡æ–°è®¡ç®—å±•å¼€ä½ç½®
        const newExpandPos = getExpandedPosition();
        setPosition(newExpandPos);
      } else {
        // è‡ªç”±çŠ¶æ€ï¼Œç¡®ä¿åœ¨å®‰å…¨åŒºåŸŸå†…
        const safeX = Math.max(20, Math.min(windowWidth - (playerDims.width + 20), position.x));
        const safeY = Math.max(20, Math.min(windowHeight - (playerDims.height + 20), position.y));
        setPosition({ x: safeX, y: safeY });
        setFreePosition({ x: safeX, y: safeY });
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [snapState, freePosition, findNearestEdge, getExpandedPosition, position, playerDims.width, playerDims.height]);

  // ğŸŒŠ åˆå§‹åŒ–æ³¢å½¢æ˜¾ç¤º
  const initWaveform = useCallback(() => {
    if (preloadOnly) {
      // é¢„è½½æ¨¡å¼ä¸‹è·³è¿‡æ³¢å½¢UIåˆ›å»ºï¼Œä»…åšè½»é‡é¢„çƒ­
      setWaveformReady(true);
      return;
    }
    if (!waveformRef.current || waveformReady) return;

    try {
      const wavesurfer = WaveSurfer.create({
        container: waveformRef.current,
        waveColor: 'var(--silver-primary-60)',
        progressColor: 'var(--silver-primary-80)',
        cursorColor: 'rgba(255, 255, 255, 0.8)',
        barWidth: 2,
        barRadius: 2,
        height: 48,
        normalize: true,
        interact: false
      });

      wavesurfer.on('ready', () => {
        setWaveformReady(true);
        console.log(`ğŸŒŠ ${t.radio.waveformReady}`);
      });

      wavesurferRef.current = wavesurfer;
      
      // æ¨¡æ‹ŸåŠ è½½
      setTimeout(() => {
        setWaveformReady(true);
      }, 500);

    } catch (error) {
      console.warn(`âŒ ${t.radio.waveformError}:`, error);
      setWaveformReady(true);
    }
  }, [waveformReady, t, preloadOnly]);

  // ğŸ¼ V2ç‰ˆæœ¬APIé›†æˆ - åŠ è½½æ­Œå•
  const loadPlaylist = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/music/playlist');
      if (response.ok) {
        const data = await response.json();
        if (data.success && Array.isArray(data.playlist)) {
          setAudioFiles(data.playlist);
          if (data.playlist.length > 0) {
            setCurrentTrack(data.playlist[0]);
            setCurrentTrackIndex(0);
          }
        }
      }
    } catch (error) {
      console.warn('âŒ åŠ è½½æ­Œå•å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®:', error);
      // ä½¿ç”¨æµ‹è¯•æ•°æ®ä½œä¸ºåå¤‡
      initTestModeAudioFiles();
    } finally {
      setIsLoading(false);
    }
  }, []);

  // ğŸ¼ åˆå§‹åŒ–æµ‹è¯•æ¨¡å¼éŸ³é¢‘æ–‡ä»¶
  const initTestModeAudioFiles = useCallback(() => {
    const testAudioFiles: AudioTrack[] = [
      {
        id: '001',
        title: 'Shaking Conditions',
        artist: 'Moodrich, Sketchy',
        duration: 240,
        bpm: 128,
        genre: 'Electronic',
        path: '/Users/masher/Music/ç½‘æ˜“äº‘éŸ³ä¹/æŸ”/001. Shaking Conditions - Moodrich, Sketchy.mp3',
        type: 'test_hardcoded',
        playCount: 0
      },
      {
        id: '002',
        title: 'Deep Space Journey',
        artist: 'Cosmic Explorer',
        duration: 320,
        bpm: 120,
        genre: 'Ambient',
        path: '/Users/masher/Music/ç½‘æ˜“äº‘éŸ³ä¹/æŸ”/002. Deep Space Journey - Cosmic Explorer.mp3',
        type: 'test_hardcoded',
        playCount: 0
      },
      {
        id: '003',
        title: 'Neon Dreams',
        artist: 'Synthwave Collective',
        duration: 280,
        bpm: 125,
        genre: 'Synthwave',
        path: '/Users/masher/Music/ç½‘æ˜“äº‘éŸ³ä¹/æŸ”/003. Neon Dreams - Synthwave Collective.mp3',
        type: 'test_hardcoded',
        playCount: 0
      },
      {
        id: '004',
        title: 'Quantum Flow',
        artist: 'Digital Mind',
        duration: 300,
        bpm: 130,
        genre: 'Techno',
        path: '/Users/masher/Music/ç½‘æ˜“äº‘éŸ³ä¹/æŸ”/004. Quantum Flow - Digital Mind.mp3',
        type: 'test_hardcoded',
        playCount: 0
      },
      {
        id: '005',
        title: 'Stellar Wind',
        artist: 'Space Traveler',
        duration: 260,
        bpm: 118,
        genre: 'Chillout',
        path: '/Users/masher/Music/ç½‘æ˜“äº‘éŸ³ä¹/æŸ”/005. Stellar Wind - Space Traveler.mp3',
        type: 'test_hardcoded',
        playCount: 0
      }
    ];
    
    setAudioFiles(testAudioFiles);
    setCurrentTrack(testAudioFiles[0]);
    console.log('ğŸ¼ æµ‹è¯•æ¨¡å¼éŸ³é¢‘æ–‡ä»¶å·²åŠ è½½:', testAudioFiles.length, 'é¦–æ­Œæ›²');
  }, []);

  // ğŸ¼ V2ç‰ˆæœ¬APIé›†æˆ - è·å–æ’­æ”¾çŠ¶æ€
  const getPlaybackStatus = useCallback(async () => {
    try {
      const response = await fetch('/api/music/status');
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          setIsPlaying(data.isPlaying || false);
          setVolume(data.volume || 0.6);
          setCurrentTime(data.currentTime || 0);
          setAudioDuration(data.duration || 0);
        }
      }
    } catch (error) {
      console.warn('âŒ è·å–æ’­æ”¾çŠ¶æ€å¤±è´¥:', error);
    }
  }, []);

  // ğŸ¼ V2ç‰ˆæœ¬APIé›†æˆ - æ’­æ”¾éŸ³ä¹
  const playMusic = useCallback(async () => {
    try {
      const response = await fetch('/api/music/play', { method: 'POST' });
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          setIsPlaying(true);
          console.log('ğŸµ å¼€å§‹æ’­æ”¾');
          // é€šè¿‡V2äº‹ä»¶ç³»ç»Ÿå‘å°„æ’­æ”¾äº‹ä»¶ - ä¿®å¤æ¥å£é”™è¯¯
          UnifiedEventBus.emitPlayback('play');
        }
      }
    } catch (error) {
      console.error('âŒ æ’­æ”¾å¤±è´¥:', error);
    }
  }, []);

  // ğŸ¼ V2ç‰ˆæœ¬APIé›†æˆ - æš‚åœéŸ³ä¹
  const pauseMusic = useCallback(async () => {
    try {
      const response = await fetch('/api/music/pause', { method: 'POST' });
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          setIsPlaying(false);
          console.log('â¸ï¸ éŸ³ä¹å·²æš‚åœ');
          // é€šè¿‡V2äº‹ä»¶ç³»ç»Ÿå‘å°„æš‚åœäº‹ä»¶ - ä¿®å¤æ¥å£é”™è¯¯
          UnifiedEventBus.emitPlayback('pause');
        }
      }
    } catch (error) {
      console.error('âŒ æš‚åœå¤±è´¥:', error);
    }
  }, []);

  // ğŸ¼ æ’­æ”¾/æš‚åœåˆ‡æ¢
  const handlePlayPause = useCallback(async () => {
    if (isPlaying) {
      await pauseMusic();
    } else {
      await playMusic();
    }
  }, [isPlaying, playMusic, pauseMusic]);

  // ğŸ¼ éŸ³é‡æ§åˆ¶
  const handleVolumeChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    
    if (wavesurferRef.current) {
      wavesurferRef.current.setVolume(newVolume);
    }
    if (audioRef.current) {
      audioRef.current.volume = newVolume;
    }
    
    // åŒæ­¥åˆ°æœåŠ¡å™¨
    fetch(`/api/music/volume?level=${newVolume}`).catch(console.warn);
  }, []);

  // ğŸ”„ åŒæ­¥æŒ‰é’®
  const handleSyncToggle = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onSyncToggle?.();
    const syncStatus = !syncActive ? t.radio.syncActive : t.radio.syncInactive;
    console.log(`ğŸ”„ ${t.radio.syncButton}: ${syncStatus}`);
  }, [syncActive, onSyncToggle, t]);

  // ğŸšª å…³é—­æŒ‰é’®
  const handleClose = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onClose?.();
    
    // æ¸…ç†èµ„æº
    if (wavesurferRef.current) {
      wavesurferRef.current.destroy();
    }
    if (audioRef.current) {
      try { audioRef.current.pause(); } catch {}
      audioRef.current.src = '';
      audioRef.current = null;
    }
    
    console.log(`ğŸšª ${t.radio.closePlayer}`);
  }, [onClose, t]);

  // åˆå§‹åŒ–
  useEffect(() => {
    initWaveform();
    
    // åˆå§‹åŒ– audio å…ƒç´ 
    const a = new Audio();
    a.crossOrigin = 'anonymous';
    a.preload = 'none';
    a.volume = volume;
    
    // éŸ³é¢‘äº‹ä»¶ç›‘å¬
    a.addEventListener('ended', () => {
      console.log('ğŸµ å½“å‰æ­Œæ›²æ’­æ”¾å®Œæ¯•');
      // ç®€åŒ–ç‰ˆï¼šä¸è‡ªåŠ¨ä¸‹ä¸€é¦–ï¼Œåªåœæ­¢æ’­æ”¾
      setIsPlaying(false);
    });
    
    a.addEventListener('error', (e) => {
      console.warn('âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
    });
    
    audioRef.current = a;
    
    // è®¢é˜…æ’­æ”¾/æš‚åœ
    const offPlayback = onPlayback((e) => {
      const s = e.data?.playbackState;
      if (s === 'play' && !isPlaying) setIsPlaying(true);
      if (s === 'pause' && isPlaying) setIsPlaying(false);
      if (s === 'stop') setIsPlaying(false);
    });
    
    // è®¢é˜…è¿‡æ¸¡ï¼ˆç®€åŒ–ç‰ˆï¼šä¸éœ€è¦å¤æ‚çš„è¿‡æ¸¡äº‹ä»¶ï¼‰
    const offTransition = onTransition((_e) => {
      console.log('ğŸšï¸ Transition received (ç®€åŒ–ç‰ˆå¿½ç•¥)');
    });
    
    // åŠ è½½æ­Œå•å’ŒçŠ¶æ€
    loadPlaylist();
    getPlaybackStatus();
    
    // ğŸ•’ è¿›å…¥ç¬¬äºŒé¡µåè‡ªåŠ¨å¸é™„é€»è¾‘ï¼šå±•å¼€10ç§’åè‡ªåŠ¨å¸é™„
    console.log('ğŸ•’ å¯åŠ¨10ç§’è‡ªåŠ¨å¸é™„å®šæ—¶å™¨');
    const timer = setTimeout(() => {
      console.log('ğŸ§² è‡ªåŠ¨æ‰§è¡Œå¸é™„æ“ä½œ');
      // ç®€åŒ–çš„è‡ªåŠ¨å¸é™„é€»è¾‘ - ç›´æ¥æ‰§è¡Œå¸é™„åˆ°å·¦è¾¹ç¼˜
      setFreePosition(prev => ({ x: 20, y: window.innerHeight - 280 - 20 }));
      setSnappedEdge(SnapEdge.Left);
      setPosition({ x: 0, y: Math.max(50, Math.min(window.innerHeight - 150, 200)) });
      setSnapState(SnapState.Snapped);
    }, 10000); // 10ç§’
    
    setAutoSnapTimer(timer);
    
    return () => {
      if (wavesurferRef.current) {
        wavesurferRef.current.destroy();
      }
      if (audioRef.current) {
        try { audioRef.current.pause(); } catch {}
        audioRef.current.src = '';
        audioRef.current = null;
      }
      if (reconnectTimerRef.current) { 
        clearTimeout(reconnectTimerRef.current); 
        reconnectTimerRef.current = null; 
      }
      
      // æ¸…ç†å®šæ—¶å™¨
      clearTimeout(timer);
      offPlayback();
      offTransition();
    };
  }, [loadPlaylist, getPlaybackStatus, initWaveform, volume]);

  // é¦–æ¬¡ç”¨æˆ·ç‚¹å‡»åè‡ªåŠ¨å°è¯•æ’­æ”¾ï¼ˆæ»¡è¶³æµè§ˆå™¨æ‰‹åŠ¿ç­–ç•¥ï¼‰
  useEffect(() => {
    const onFirstUserGesture = async () => {
      if (!autoplayArmedRef.current) return;
      autoplayArmedRef.current = false;
      
      // è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€é¦–æ­Œ
      if (audioFiles.length > 0) {
        await playMusic();
      }
    };
    window.addEventListener('click', onFirstUserGesture, { once: true, capture: true });
    return () => {
      try { window.removeEventListener('click', onFirstUserGesture, true as any); } catch {}
    };
  }, [playMusic, audioFiles]);

  // ğŸ¨ æ ¹æ®çŠ¶æ€å†³å®šæ ·å¼
  const isMinimized = snapState === SnapState.Snapped;
  const isExpanded = snapState === SnapState.Expanded;
  
  // è®¡ç®—å®¹å™¨æ ·å¼
  const containerStyle = {
    position: 'fixed' as const,
    left: position.x,
    top: position.y,
    width: isMinimized ? 60 : 360,
    height: 280,
    zIndex: 85,
    cursor: snapState === SnapState.Snapped ? 'pointer' : 'move',
    userSelect: 'none' as const,
    touchAction: 'none' as const,
  };

  // è®¡ç®—å†…å®¹æ ·å¼
  const contentStyle = {
    opacity: isMinimized ? 0 : 1,
    transform: isMinimized ? 'scale(0.8)' : 'scale(1)',
    transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  };

  // è®¡ç®—å¸é™„æŒ‰é’®æ ·å¼
  const snapButtonStyle = {
    position: 'absolute' as const,
    top: isMinimized ? '50%' : '10px',
    right: isMinimized ? '50%' : '10px',
    transform: isMinimized ? 'translate(50%, -50%)' : 'none',
    width: isMinimized ? 40 : 32,
    height: isMinimized ? 40 : 32,
    borderRadius: '50%',
    background: 'var(--silver-primary-80)',
    border: '2px solid var(--silver-primary-60)',
    color: 'var(--silver-primary-20)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    fontSize: isMinimized ? '20px' : '16px',
    transition: 'all 0.2s ease',
    zIndex: 10,
  };

  if (preloadOnly) {
    return null;
  }

  return (
    <motion.div
      ref={playerRef}
      style={containerStyle}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ type: "spring", stiffness: 300, damping: 30 }}
    >
      {/* å¸é™„åˆ‡æ¢æŒ‰é’® */}
      <motion.button
        style={snapButtonStyle}
        onClick={handleSnapToggle}
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        title={isMinimized ? 'å±•å¼€æ’­æ”¾å™¨' : 'å¸é™„åˆ°è¾¹ç¼˜'}
      >
        {isMinimized ? 'â–¶' : 'ğŸ§²'}
      </motion.button>

      {/* ä¸»å†…å®¹åŒºåŸŸ */}
      <motion.div style={contentStyle}>
        {/* æ’­æ”¾å™¨å¤´éƒ¨ */}
        <div className="bg-silver-primary-90/95 backdrop-blur-md border border-silver-primary-60 rounded-t-lg p-3 flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-red-500 rounded-full"></div>
            <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>
            <div className="w-3 h-3 bg-green-500 rounded-full"></div>
          </div>
          <div className="text-silver-primary-20 text-sm font-mono">
            {isMinimized ? 'RADIO' : 'TIANGONG RADIO'}
          </div>
          <div className="flex items-center space-x-2">
            <button
              onClick={handleSyncToggle}
              className={`w-6 h-6 rounded-full flex items-center justify-center text-xs transition-colors ${
                syncActive 
                  ? 'bg-silver-primary-60 text-silver-primary-20' 
                  : 'bg-silver-primary-40 text-silver-primary-60'
              }`}
              title={syncActive ? 'åŒæ­¥å·²å¯ç”¨' : 'åŒæ­¥å·²ç¦ç”¨'}
            >
              ğŸ”„
            </button>
            <button
              onClick={handleClose}
              className="w-6 h-6 rounded-full bg-silver-primary-40 text-silver-primary-60 hover:bg-silver-primary-60 hover:text-silver-primary-20 transition-colors flex items-center justify-center text-xs"
              title="å…³é—­æ’­æ”¾å™¨"
            >
              âœ•
            </button>
          </div>
        </div>

        {/* æ’­æ”¾å™¨ä¸»ä½“ */}
        <div className="bg-silver-primary-95/95 backdrop-blur-md border-x border-b border-silver-primary-60 rounded-b-lg p-4">
          {/* å½“å‰æ’­æ”¾ä¿¡æ¯ */}
          {currentTrack && (
            <div className="mb-4 text-center">
              <div className="text-silver-primary-20 font-medium text-sm mb-1">
                {currentTrack.title}
              </div>
              {currentTrack.artist && (
                <div className="text-silver-primary-40 text-xs">
                  {currentTrack.artist}
                </div>
              )}
              {currentTrack.key && (
                <div className="text-silver-primary-50 text-xs mt-1">
                  è°ƒæ€§: {currentTrack.key}
                </div>
              )}
            </div>
          )}

          {/* æ³¢å½¢æ˜¾ç¤º */}
          <div 
            ref={waveformRef} 
            className="w-full h-12 bg-silver-primary-90 rounded mb-4 flex items-center justify-center"
          >
            {!waveformReady && (
              <div className="text-silver-primary-40 text-xs">åŠ è½½æ³¢å½¢...</div>
            )}
          </div>

          {/* æ’­æ”¾æ§åˆ¶ - ç®€åŒ–ç‰ˆï¼šåªæœ‰æ’­æ”¾/æš‚åœæŒ‰é’® */}
          <div className="flex items-center justify-center mb-4">
            <button
              onClick={handlePlayPause}
              className="w-16 h-16 rounded-full bg-silver-primary-60 text-silver-primary-20 hover:bg-silver-primary-80 transition-colors flex items-center justify-center text-xl"
              title={isPlaying ? 'æš‚åœ' : 'æ’­æ”¾'}
            >
              {isPlaying ? 'â¸ï¸' : 'â–¶ï¸'}
            </button>
          </div>

          {/* éŸ³é‡æ§åˆ¶ */}
          <div className="flex items-center space-x-2">
            <span className="text-silver-primary-40 text-xs">ğŸ”Š</span>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={volume}
              onChange={handleVolumeChange}
              className="flex-1 h-2 bg-silver-primary-80 rounded-lg appearance-none cursor-pointer slider"
              title={`éŸ³é‡: ${Math.round(volume * 100)}%`}
            />
            <div className="text-silver-primary-60 font-mono text-xs min-w-[28px] text-right">
              {Math.round(volume * 100)}%
            </div>
          </div>

          {/* æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ */}
          {audioFiles.length > 0 && (
            <div className="mt-4 text-center">
              <div className="text-silver-primary-40 text-xs">
                æ­Œå•: {currentTrackIndex + 1} / {audioFiles.length}
              </div>
              <div className="text-silver-primary-30 text-xs mt-1">
                {audioFiles[currentTrackIndex]?.title || 'æœªé€‰æ‹©æ­Œæ›²'}
              </div>
            </div>
          )}

          {/* åŠ è½½çŠ¶æ€ */}
          {isLoading && (
            <div className="mt-4 text-center">
              <div className="text-silver-primary-40 text-xs">åŠ è½½ä¸­...</div>
            </div>
          )}
        </div>
      </motion.div>

      {/* è‡ªå®šä¹‰æ»‘å—æ ·å¼ */}
      <style jsx>{`
        .slider::-webkit-slider-thumb {
          appearance: none;
          height: 16px;
          width: 16px;
          border-radius: 50%;
          background: var(--silver-primary-60);
          cursor: pointer;
          border: 2px solid var(--silver-primary-80);
        }
        
        .slider::-moz-range-thumb {
          height: 16px;
          width: 16px;
          border-radius: 50%;
          background: var(--silver-primary-60);
          border: 2px solid var(--silver-primary-80);
        }
      `}</style>
    </motion.div>
  );
};