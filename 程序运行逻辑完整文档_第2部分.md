# 🚀 个人网站项目V2 程序运行逻辑完整文档 - 第2部分

## 📋 文档信息

- **创建时间**: 2025年8月25日
- **文档类型**: 程序运行逻辑完整文档 (第2部分)
- **基于文档**: 模块档案集 (10个核心模块深度分析)
- **文档状态**: ✅ 第2部分已完成
- **维护人员**: AI助手

---

## 🎵 音乐系统运行逻辑

### 1. 播放状态监听

#### 1.1 状态轮询机制
```typescript
// AutoDJManager定时轮询
private async tick(): Promise<void> {
  // 通过事件系统获取播放状态
  const mockData = {
    title: '模拟曲目',
    artist: '模拟艺术家',
    bpm: 128,
    keyCamelot: '8B'
  };
  
  const trackKey = `${mockData.artist} - ${mockData.title}`;
  
  // 检测曲目切换
  if (trackKey && trackKey !== this.lastTrackKey) {
    const fromTrack = this.lastTrackKey || undefined;
    this.lastTrackKey = trackKey;
    
    // 广播过渡事件
    UnifiedEventBus.emit({
      namespace: 'automix',
      type: 'transition',
      timestamp: Date.now(),
      data: { action: 'next', fromTrack, toTrack: trackKey, index: 0 }
    });
    
    // 广播播放事件
    UnifiedEventBus.emitPlayback('play');
  }
  
  // 广播BPM
  if (typeof mockData.bpm === 'number' && Number.isFinite(mockData.bpm)) {
    UnifiedEventBus.emitBpm(mockData.bpm);
  }
}
```

#### 1.2 事件广播
```typescript
// 播放状态事件广播
UnifiedEventBus.emitBpm(bpm: number): void {
  this.emit({
    namespace: 'automix',
    type: 'bpm',
    timestamp: Date.now(),
    data: { bpm }
  });
}

UnifiedEventBus.emitPlayback(action: string): void {
  this.emit({
    namespace: 'automix',
    type: 'playback',
    timestamp: Date.now(),
    data: { action }
  });
}
```

### 2. AI混音算法

#### 2.1 算法核心推进
```typescript
// AutoMixManager定时推进算法核心
private tickCore(): void {
  try {
    // 推进核心一步
    const result = this.core.stepOnce({
      mood: this.mood,
      audioFeatures: this.audioFeaturesFromBpm(),
      nowPlaying: this.nowPlaying,
      perf: this.perf
    });
    
    // 输出新的预设
    if (result?.preset && result.preset.id !== this.lastPresetId) {
      this.lastPresetId = result.preset.id;
      UnifiedEventBus.emitPreset(result.preset.id);
    }
    
    // 输出新的效果管道
    if (result?.pipeline) {
      UnifiedEventBus.emit({
        namespace: 'visualization',
        type: 'effect',
        timestamp: Date.now(),
        data: { pipeline: result.pipeline }
      });
    }
  } catch (error) {
    console.error('AutoMixManager: 核心推进失败', error);
  }
}
```

#### 2.2 音乐结构感知
```typescript
// UnifiedTechnoMoodCore音乐结构感知
function segmentFromStep(st: StepState): Segment {
  if (st.phaseInPhrase === 0 && st.step === 0) return 'drop';
  if (st.phaseInPhrase === st.phraseBars - 1) return 'fill';
  if (st.phaseInPhrase >= st.phraseBars - 2) return 'build';
  return 'steady';
}

// 段落增强
const segBoost = (np?.segment === 'build') ? 0.10 : 
                 (np?.segment === 'drop') ? 0.20 : 
                 (np?.segment === 'fill') ? 0.15 : 
                 (np?.segment === 'break') ? -0.05 : 0.0;
```

---

## 🎨 可视化系统运行逻辑

### 1. 背景管理系统

#### 1.1 GPU优化渲染
```typescript
// BackgroundManager GPU检测和优化
class BackgroundManager {
  private detectGPU(): void {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    
    if (gl) {
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      if (debugInfo) {
        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        this.gpuTier = this.classifyGPU(renderer);
      }
    }
  }
  
  private classifyGPU(renderer: string): 'h' | 'm' | 'l' {
    if (renderer.includes('RTX') || renderer.includes('GTX 1080')) return 'h';
    if (renderer.includes('GTX') || renderer.includes('RX')) return 'm';
    return 'l';
  }
}
```

#### 1.2 背景切换逻辑
```typescript
// 智能背景切换
private switchBackground(preset: string): void {
  const backgroundIndex = this.presetToIndex(preset);
  
  if (backgroundIndex !== this.currentBackgroundIndex) {
    // 预加载新背景
    this.preloadBackground(backgroundIndex);
    
    // 平滑切换
    this.transitionToBackground(backgroundIndex);
    
    // 更新当前索引
    this.currentBackgroundIndex = backgroundIndex;
  }
}
```

### 2. 主题系统

#### 2.1 动态主题生成
```typescript
// DynamicThemeManager情绪到主题映射
function mapMoodToTokens(energy: number, valence: number, arousal: number): ThemeTokens {
  // 根据能量调节强度/运动感
  const intensity = Math.min(1, Math.max(0, energy));
  const motion = Math.min(1, Math.max(0, (energy + arousal) / 2));
  const contrast = Math.min(1, Math.max(0, (arousal * 0.6 + 0.2)));
  
  // 将valence [-1,1] 映射到冷暖色
  const warm = Math.round(((valence + 1) / 2) * 255);
  const cool = 255 - warm;
  const accent = `#${warm.toString(16).padStart(2, '0')}${cool.toString(16).padStart(2, '0')}cc`;
  
  return { accent, background: '#0b0f14', intensity, motion, contrast };
}
```

#### 2.2 主题广播
```typescript
// 主题变化实时广播
init(): void {
  this.unsubscribers.push(
    onMood((e) => {
      const m = e.data?.mood || { energy: 0.6, valence: 0.0, arousal: 0.5 };
      this.current = mapMoodToTokens(m.energy, m.valence, m.arousal);
      
      UnifiedEventBus.emit({ 
        namespace: 'global', 
        type: 'config', 
        timestamp: Date.now(), 
        data: { theme: this.current } 
      });
    })
  );
}
```

### 3. 可视化效果映射

#### 3.1 预设选择逻辑
```typescript
// VisualizationEffectManager预设选择
function pickPresetByTheme(theme: ThemeTokens): string {
  const { intensity, motion, contrast } = theme;
  
  if (intensity < 0.35 && contrast < 0.4) return 'silver_pure';
  if (motion < 0.45 && intensity < 0.55) return 'silver_mist';
  if (intensity > 0.75 && motion > 0.6) return 'metallic_flow';
  if (contrast > 0.65) return 'cosmic_silver';
  return 'liquid_chrome';
}
```

#### 3.2 Pipeline效果处理
```typescript
// Pipeline效果优先处理
const offEffect = UnifiedEventBus.on('visualization', 'effect', (e) => {
  const pipeline = (e as any).data?.pipeline;
  if (!pipeline) return;
  
  // 如果pipeline带有presetId，映射为可用的背景名
  const presetId: string | undefined = pipeline?.presetId;
  if (presetId) {
    const preset = this.mapPresetIdToName(presetId);
    if (preset && preset !== this.lastPreset) {
      this.lastPreset = preset;
      UnifiedEventBus.emitPreset(preset);
    }
  }
});
```

---

## 🧠 情绪系统运行逻辑

### 1. 情绪核心算法

#### 1.1 EVA模型实现
```typescript
// EmotionCoreManager情绪计算
class EmotionCoreManager {
  private calculateEmotion(input: EmotionInput): EmotionState {
    // 能量计算 (Energy)
    const energy = this.calculateEnergy(input.bpm, input.audioFeatures, input.userInteraction);
    
    // 情感值计算 (Valence)
    const valence = this.calculateValence(input.musicMood, input.userPreference, input.context);
    
    // 唤醒度计算 (Arousal)
    const arousal = this.calculateArousal(input.intensity, input.complexity, input.tempo);
    
    return { energy, valence, arousal };
  }
  
  private calculateEnergy(bpm: number, audioFeatures: AudioFeatures, userInteraction: UserInteraction): number {
    // 基于BPM的能量计算
    const bpmEnergy = Math.min(1, Math.max(0, (bpm - 80) / 120));
    
    // 基于音频特征的能量计算
    const audioEnergy = (audioFeatures.rms + audioFeatures.flux) / 2;
    
    // 基于用户交互的能量计算
    const interactionEnergy = userInteraction.intensity || 0.5;
    
    // 加权融合
    return 0.4 * bpmEnergy + 0.4 * audioEnergy + 0.2 * interactionEnergy;
  }
}
```

#### 1.2 随机算法集成
```typescript
// 随机情绪集成
class RandomEmotionIntegration {
  private updateEmotionRandomness(emotion: EmotionState): void {
    // 基于情绪的随机性控制
    const randomness = this.calculateRandomness(emotion);
    
    // 更新随机种子
    this.updateSeed(randomness);
    
    // 调整随机算法参数
    this.adjustRandomParameters(emotion);
  }
  
  private calculateRandomness(emotion: EmotionState): number {
    // 高能量时增加随机性
    const energyRandomness = emotion.energy * 0.3;
    
    // 高唤醒度时增加随机性
    const arousalRandomness = emotion.arousal * 0.2;
    
    // 情感值影响随机性
    const valenceRandomness = (1 - Math.abs(emotion.valence)) * 0.5;
    
    return Math.min(1, energyRandomness + arousalRandomness + valenceRandomness);
  }
}
```

### 2. 切歌手法桥接

#### 2.1 情绪到手法映射
```typescript
// 情绪→手法建议桥接
class EmotionTechniqueBridge {
  private emitTechniqueRecommend(emotion: EmotionState): void {
    // 选择合适的手法
    const technique = this.chooseTechnique(emotion);
    
    // 生成建议原因
    const reason = this.generateReason(emotion, technique);
    
    // 广播手法建议事件
    UnifiedEventBus.emit({
      namespace: 'automix',
      type: 'technique_recommend',
      timestamp: Date.now(),
      data: {
        technique,
        reason,
        emotion: emotion,
        confidence: this.calculateConfidence(emotion, technique)
      }
    });
  }
  
  private chooseTechnique(emotion: EmotionState): string {
    const { energy, valence, arousal } = emotion;
    
    if (energy > 0.8 && arousal > 0.7) return 'double_drop_32';
    if (energy > 0.6 && valence > 0.3) return 'build_up_16';
    if (arousal > 0.8) return 'break_down_8';
    if (valence < -0.5) return 'mood_shift_32';
    
    return 'smooth_transition_16';
  }
}
```

---

## 📊 性能监控和遥测

### 1. 性能指标收集

#### 1.1 实时性能监控
```typescript
// BackgroundManager性能监控
class BackgroundManager {
  private monitorPerformance(): void {
    this.performanceMonitor = setInterval(() => {
      const metrics = {
        fps: this.calculateFPS(),
        memory: this.getMemoryUsage(),
        gpu: this.getGPUPerformance(),
        timestamp: Date.now()
      };
      
      // 广播性能指标
      UnifiedEventBus.emit({
        namespace: 'global',
        type: 'performance',
        timestamp: Date.now(),
        data: { performance: metrics }
      });
      
      // 自适应质量调整
      this.adjustQuality(metrics);
    }, 1000); // 每秒监控一次
  }
}
```

#### 1.2 遥测数据上报
```typescript
// TelemetryManager数据上报
class TelemetryManager {
  constructor() {
    // 500ms节流：合并高频事件，降低后端压力
    this.sendThrottled = throttle((evt: TelemetryEvent) => {
      fetch('/api/event', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(evt),
      }).catch(() => {});
    }, 500, { leading: true, trailing: true });
  }
  
  init(): void {
    // 订阅关键事件
    this.unsubscribers.push(
      onEnergy((e) => this.sendThrottled({ kind: 'energy', payload: { value: e.data?.energy } })),
      onBpm((e) => this.sendThrottled({ kind: 'bpm', payload: { value: e.data?.bpm } })),
      onMood((e) => this.sendThrottled({ kind: 'mood', payload: e.data?.mood }))
    );
  }
}
```

### 2. 自适应优化

#### 2.1 质量自适应调整
```typescript
// 基于性能的自适应调整
private adjustQuality(metrics: PerformanceMetrics): void {
  if (metrics.fps < 30) {
    // 帧率过低，降低质量
    this.reduceQuality();
  } else if (metrics.fps > 55 && metrics.memory < 0.8) {
    // 性能良好，提升质量
    this.increaseQuality();
  }
}

private reduceQuality(): void {
  // 降低着色器复杂度
  this.shaderQuality = Math.max(0.5, this.shaderQuality - 0.1);
  
  // 减少粒子数量
  this.particleCount = Math.max(100, this.particleCount * 0.8);
  
  // 简化几何体
  this.geometryComplexity = Math.max(0.3, this.geometryComplexity - 0.1);
}
```

#### 2.2 网络自适应
```typescript
// 基于网络状况的自适应
class NetworkAdaptive {
  private adaptToNetwork(): void {
    const networkQuality = this.assessNetworkQuality();
    
    if (networkQuality === 'poor') {
      // 网络较差时减少数据上报
      this.telemetryManager.setReportInterval(5000); // 5秒上报一次
      
      // 使用本地缓存
      this.enableLocalCache();
    } else if (networkQuality === 'excellent') {
      // 网络良好时增加数据上报
      this.telemetryManager.setReportInterval(1000); // 1秒上报一次
      
      // 禁用本地缓存
      this.disableLocalCache();
    }
  }
}
```

---

**文档状态**: ✅ 第2部分已完成  
**创建时间**: 2025年8月25日  
**维护人员**: AI助手  
**文档版本**: v1.0.0  
**下一部分**: 错误处理和系统扩展
